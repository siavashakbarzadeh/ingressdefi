import { __decorate, __param } from 'tslib';
import { ɵɵdefineInjectable, Injectable, ComponentFactoryResolver, ApplicationRef, Injector, Optional, Inject, ɵɵinject, INJECTOR, InjectionToken, Input, HostListener, Component, EventEmitter, Output, Directive, ContentChild, ElementRef, ChangeDetectionStrategy, ViewChild, Pipe, Renderer2, NgModule } from '@angular/core';
import { DOCUMENT, CommonModule } from '@angular/common';
import { Subject, BehaviorSubject, merge } from 'rxjs';
import { shareReplay, takeUntil, filter, tap, map, distinctUntilChanged } from 'rxjs/operators';
import { trigger, transition, style, animate, sequence } from '@angular/animations';
import { DateTime, Info } from 'luxon';
import { NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';
import * as ɵngcc2 from '@angular/forms';

function NgxMaterialTimepickerContainerComponent_div_11_ngx_material_timepicker_24_hours_face_1_Template(rf, ctx) { if (rf & 1) {
    const _r12 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "ngx-material-timepicker-24-hours-face", 17);
    ɵngcc0.ɵɵlistener("hourChange", function NgxMaterialTimepickerContainerComponent_div_11_ngx_material_timepicker_24_hours_face_1_Template_ngx_material_timepicker_24_hours_face_hourChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r12); const ctx_r11 = ɵngcc0.ɵɵnextContext(2); return ctx_r11.onHourChange($event); })("hourSelected", function NgxMaterialTimepickerContainerComponent_div_11_ngx_material_timepicker_24_hours_face_1_Template_ngx_material_timepicker_24_hours_face_hourSelected_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r12); const ctx_r13 = ɵngcc0.ɵɵnextContext(2); return ctx_r13.onHourSelected($event); });
    ɵngcc0.ɵɵpipe(1, "async");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r8 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("selectedHour", ɵngcc0.ɵɵpipeBind1(1, 4, ctx_r8.selectedHour))("minTime", ctx_r8.minTime)("maxTime", ctx_r8.maxTime)("format", ctx_r8.format);
} }
function NgxMaterialTimepickerContainerComponent_div_11_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    const _r15 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "ngx-material-timepicker-12-hours-face", 18);
    ɵngcc0.ɵɵlistener("hourChange", function NgxMaterialTimepickerContainerComponent_div_11_ng_template_2_Template_ngx_material_timepicker_12_hours_face_hourChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r15); const ctx_r14 = ɵngcc0.ɵɵnextContext(2); return ctx_r14.onHourChange($event); })("hourSelected", function NgxMaterialTimepickerContainerComponent_div_11_ng_template_2_Template_ngx_material_timepicker_12_hours_face_hourSelected_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r15); const ctx_r16 = ɵngcc0.ɵɵnextContext(2); return ctx_r16.onHourSelected($event); });
    ɵngcc0.ɵɵpipe(1, "async");
    ɵngcc0.ɵɵpipe(2, "async");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r10 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("selectedHour", ɵngcc0.ɵɵpipeBind1(1, 4, ctx_r10.selectedHour))("period", ɵngcc0.ɵɵpipeBind1(2, 6, ctx_r10.selectedPeriod))("minTime", ctx_r10.minTime)("maxTime", ctx_r10.maxTime);
} }
function NgxMaterialTimepickerContainerComponent_div_11_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div");
    ɵngcc0.ɵɵtemplate(1, NgxMaterialTimepickerContainerComponent_div_11_ngx_material_timepicker_24_hours_face_1_Template, 2, 6, "ngx-material-timepicker-24-hours-face", 15);
    ɵngcc0.ɵɵtemplate(2, NgxMaterialTimepickerContainerComponent_div_11_ng_template_2_Template, 3, 8, "ng-template", null, 16, ɵngcc0.ɵɵtemplateRefExtractor);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const _r9 = ɵngcc0.ɵɵreference(3);
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.format === 24)("ngIfElse", _r9);
} }
function NgxMaterialTimepickerContainerComponent_ngx_material_timepicker_minutes_face_12_Template(rf, ctx) { if (rf & 1) {
    const _r18 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "ngx-material-timepicker-minutes-face", 19);
    ɵngcc0.ɵɵlistener("minuteChange", function NgxMaterialTimepickerContainerComponent_ngx_material_timepicker_minutes_face_12_Template_ngx_material_timepicker_minutes_face_minuteChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r18); const ctx_r17 = ɵngcc0.ɵɵnextContext(); return ctx_r17.onMinuteChange($event); });
    ɵngcc0.ɵɵpipe(1, "async");
    ɵngcc0.ɵɵpipe(2, "async");
    ɵngcc0.ɵɵpipe(3, "async");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    var tmp_1_0 = null;
    ɵngcc0.ɵɵproperty("selectedMinute", ɵngcc0.ɵɵpipeBind1(1, 7, ctx_r1.selectedMinute))("selectedHour", (tmp_1_0 = ɵngcc0.ɵɵpipeBind1(2, 9, ctx_r1.selectedHour)) == null ? null : tmp_1_0.time)("minTime", ctx_r1.minTime)("maxTime", ctx_r1.maxTime)("format", ctx_r1.format)("period", ɵngcc0.ɵɵpipeBind1(3, 11, ctx_r1.selectedPeriod))("minutesGap", ctx_r1.minutesGap);
} }
function NgxMaterialTimepickerContainerComponent_ng_container_15_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function NgxMaterialTimepickerContainerComponent_ng_container_17_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function NgxMaterialTimepickerContainerComponent_ng_template_18_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "ngx-material-timepicker-button");
    ɵngcc0.ɵɵtext(1, "Cancel");
    ɵngcc0.ɵɵelementEnd();
} }
function NgxMaterialTimepickerContainerComponent_ng_template_20_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "ngx-material-timepicker-button");
    ɵngcc0.ɵɵtext(1, "Ok");
    ɵngcc0.ɵɵelementEnd();
} }
const _c0 = function (a0) { return { "timepicker-backdrop-overlay--transparent": a0 }; };
function NgxMaterialTimepickerToggleComponent__svg_svg_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "svg", 2);
    ɵngcc0.ɵɵelement(1, "path", 3);
    ɵngcc0.ɵɵelementEnd();
} }
const _c1 = [[["", "ngxMaterialTimepickerToggleIcon", ""]]];
const _c2 = ["[ngxMaterialTimepickerToggleIcon]"];
const _c3 = ["clockFace"];
const _c4 = ["clockHand"];
const _c5 = function (a0) { return { "transform": a0 }; };
const _c6 = function (a0, a1) { return { "active": a0, "disabled": a1 }; };
function NgxMaterialTimepickerFaceComponent_div_2_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 9);
    ɵngcc0.ɵɵelementStart(1, "span", 10);
    ɵngcc0.ɵɵpipe(2, "activeHour");
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵpipe(4, "timeLocalizer");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const time_r7 = ctx.$implicit;
    const ctx_r5 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngStyle", ɵngcc0.ɵɵpureFunction1(11, _c5, "rotateZ(" + time_r7.angle + "deg) translateX(-50%)"));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngStyle", ɵngcc0.ɵɵpureFunction1(13, _c5, "rotateZ(-" + time_r7.angle + "deg)"))("ngClass", ɵngcc0.ɵɵpureFunction2(15, _c6, ɵngcc0.ɵɵpipeBind3(2, 4, time_r7.time, ctx_r5.selectedTime.time, ctx_r5.isClockFaceDisabled), time_r7.disabled));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate1(" ", ɵngcc0.ɵɵpipeBind2(4, 8, time_r7.time, ctx_r5.timeUnit.HOUR), " ");
} }
function NgxMaterialTimepickerFaceComponent_div_2_div_3_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 13);
    ɵngcc0.ɵɵelementStart(1, "span", 10);
    ɵngcc0.ɵɵpipe(2, "activeHour");
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵpipe(4, "timeLocalizer");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const time_r9 = ctx.$implicit;
    const ctx_r8 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵstyleProp("height", ctx_r8.innerClockFaceSize, "px");
    ɵngcc0.ɵɵproperty("ngStyle", ɵngcc0.ɵɵpureFunction1(13, _c5, "rotateZ(" + time_r9.angle + "deg) translateX(-50%)"));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngStyle", ɵngcc0.ɵɵpureFunction1(15, _c5, "rotateZ(-" + time_r9.angle + "deg)"))("ngClass", ɵngcc0.ɵɵpureFunction2(17, _c6, ɵngcc0.ɵɵpipeBind3(2, 6, time_r9.time, ctx_r8.selectedTime == null ? null : ctx_r8.selectedTime.time, ctx_r8.isClockFaceDisabled), time_r9.disabled));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate1(" ", ɵngcc0.ɵɵpipeBind2(4, 10, time_r9.time, ctx_r8.timeUnit.HOUR), "");
} }
function NgxMaterialTimepickerFaceComponent_div_2_div_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 11);
    ɵngcc0.ɵɵtemplate(1, NgxMaterialTimepickerFaceComponent_div_2_div_3_div_1_Template, 5, 20, "div", 12);
    ɵngcc0.ɵɵpipe(2, "slice");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r6 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵstyleProp("top", "calc(50% - " + ctx_r6.innerClockFaceSize + "px)");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ɵngcc0.ɵɵpipeBind3(2, 4, ctx_r6.faceTime, 12, 24))("ngForTrackBy", ctx_r6.trackByTime);
} }
function NgxMaterialTimepickerFaceComponent_div_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 6);
    ɵngcc0.ɵɵtemplate(1, NgxMaterialTimepickerFaceComponent_div_2_div_1_Template, 5, 18, "div", 7);
    ɵngcc0.ɵɵpipe(2, "slice");
    ɵngcc0.ɵɵtemplate(3, NgxMaterialTimepickerFaceComponent_div_2_div_3_Template, 3, 8, "div", 8);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ɵngcc0.ɵɵpipeBind3(2, 3, ctx_r1.faceTime, 0, 12))("ngForTrackBy", ctx_r1.trackByTime);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.faceTime.length > 12);
} }
function NgxMaterialTimepickerFaceComponent_ng_template_5_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 9);
    ɵngcc0.ɵɵelementStart(1, "span", 10);
    ɵngcc0.ɵɵpipe(2, "activeMinute");
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵpipe(4, "timeLocalizer");
    ɵngcc0.ɵɵpipe(5, "minutesFormatter");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const time_r11 = ctx.$implicit;
    const ctx_r10 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngStyle", ɵngcc0.ɵɵpureFunction1(15, _c5, "rotateZ(" + time_r11.angle + "deg) translateX(-50%)"));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngStyle", ɵngcc0.ɵɵpureFunction1(17, _c5, "rotateZ(-" + time_r11.angle + "deg)"))("ngClass", ɵngcc0.ɵɵpureFunction2(19, _c6, ɵngcc0.ɵɵpipeBind4(2, 4, time_r11.time, ctx_r10.selectedTime == null ? null : ctx_r10.selectedTime.time, ctx_r10.minutesGap, ctx_r10.isClockFaceDisabled), time_r11.disabled));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate1(" ", ɵngcc0.ɵɵpipeBind2(4, 9, ɵngcc0.ɵɵpipeBind2(5, 12, time_r11.time, ctx_r10.minutesGap), ctx_r10.timeUnit.MINUTE), "");
} }
function NgxMaterialTimepickerFaceComponent_ng_template_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 6);
    ɵngcc0.ɵɵtemplate(1, NgxMaterialTimepickerFaceComponent_ng_template_5_div_1_Template, 6, 22, "div", 7);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r4.faceTime)("ngForTrackBy", ctx_r4.trackByTime);
} }
const _c7 = function (a0) { return { "clock-face__clock-hand_minute": a0 }; };
const _c8 = ["*"];
function NgxMaterialTimepickerDialComponent_div_8_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function NgxMaterialTimepickerDialComponent_div_8_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "small", 10);
    ɵngcc0.ɵɵtext(1, " * use arrows (");
    ɵngcc0.ɵɵelementStart(2, "span");
    ɵngcc0.ɵɵtext(3, "\u21C5");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtext(4, ") to change the time");
    ɵngcc0.ɵɵelementEnd();
} }
const _c9 = function (a0) { return { "timepicker-dial__hint-container--hidden": a0 }; };
function NgxMaterialTimepickerDialComponent_div_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 7);
    ɵngcc0.ɵɵtemplate(1, NgxMaterialTimepickerDialComponent_div_8_ng_container_1_Template, 1, 0, "ng-container", 8);
    ɵngcc0.ɵɵtemplate(2, NgxMaterialTimepickerDialComponent_div_8_ng_template_2_Template, 5, 0, "ng-template", null, 9, ɵngcc0.ɵɵtemplateRefExtractor);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const _r2 = ɵngcc0.ɵɵreference(3);
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(2, _c9, !ctx_r0.isHintVisible));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r0.editableHintTmpl ? ctx_r0.editableHintTmpl : _r2);
} }
const _c10 = function (a0) { return { "timepicker-dial__period--hidden": a0 }; };
const _c11 = function (a0) { return { "timepicker-dial__item_active": a0 }; };
function NgxMaterialTimepickerDialControlComponent_input_0_Template(rf, ctx) { if (rf & 1) {
    const _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "input", 2);
    ɵngcc0.ɵɵlistener("ngModelChange", function NgxMaterialTimepickerDialControlComponent_input_0_Template_input_ngModelChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); const ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.time = $event; })("input", function NgxMaterialTimepickerDialControlComponent_input_0_Template_input_input_0_listener() { ɵngcc0.ɵɵrestoreView(_r4); const ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.updateTime(); })("focus", function NgxMaterialTimepickerDialControlComponent_input_0_Template_input_focus_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); const ctx_r6 = ɵngcc0.ɵɵnextContext(); return ctx_r6.saveTimeAndChangeTimeUnit($event, ctx_r6.timeUnit); });
    ɵngcc0.ɵɵpipe(1, "timeLocalizer");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(7, _c11, ctx_r0.isActive))("ngModel", ɵngcc0.ɵɵpipeBind2(1, 4, ctx_r0.time, ctx_r0.timeUnit))("disabled", ctx_r0.disabled)("timepickerAutofocus", ctx_r0.isActive);
} }
function NgxMaterialTimepickerDialControlComponent_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    const _r8 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "input", 3);
    ɵngcc0.ɵɵlistener("ngModelChange", function NgxMaterialTimepickerDialControlComponent_ng_template_1_Template_input_ngModelChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r8); const ctx_r7 = ɵngcc0.ɵɵnextContext(); return ctx_r7.onModelChange($event); })("input", function NgxMaterialTimepickerDialControlComponent_ng_template_1_Template_input_input_0_listener() { ɵngcc0.ɵɵrestoreView(_r8); const ctx_r9 = ɵngcc0.ɵɵnextContext(); return ctx_r9.updateTime(); })("focus", function NgxMaterialTimepickerDialControlComponent_ng_template_1_Template_input_focus_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r8); const ctx_r10 = ɵngcc0.ɵɵnextContext(); return ctx_r10.saveTimeAndChangeTimeUnit($event, ctx_r10.timeUnit); })("keydown", function NgxMaterialTimepickerDialControlComponent_ng_template_1_Template_input_keydown_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r8); const ctx_r11 = ɵngcc0.ɵɵnextContext(); return ctx_r11.onKeydown($event); })("keypress", function NgxMaterialTimepickerDialControlComponent_ng_template_1_Template_input_keypress_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r8); const ctx_r12 = ɵngcc0.ɵɵnextContext(); return ctx_r12.changeTimeByKeyboard($event); });
    ɵngcc0.ɵɵpipe(1, "timeLocalizer");
    ɵngcc0.ɵɵpipe(2, "timeParser");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(11, _c11, ctx_r2.isActive))("ngModel", ɵngcc0.ɵɵpipeBind3(1, 4, ɵngcc0.ɵɵpipeBind2(2, 8, ctx_r2.time, ctx_r2.timeUnit), ctx_r2.timeUnit, true))("disabled", ctx_r2.disabled)("timepickerAutofocus", ctx_r2.isActive);
} }
function NgxMaterialTimepickerPeriodComponent_div_5_Template(rf, ctx) { if (rf & 1) {
    const _r2 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 3);
    ɵngcc0.ɵɵlistener("@scaleInOut.done", function NgxMaterialTimepickerPeriodComponent_div_5_Template_div_animation_scaleInOut_done_0_listener() { ɵngcc0.ɵɵrestoreView(_r2); const ctx_r1 = ɵngcc0.ɵɵnextContext(); return ctx_r1.animationDone(); });
    ɵngcc0.ɵɵelementStart(1, "p");
    ɵngcc0.ɵɵtext(2, "Current time would be invalid in this period.");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵproperty("@scaleInOut", undefined);
} }
function NgxTimepickerFieldComponent_ngx_timepicker_period_selector_7_Template(rf, ctx) { if (rf & 1) {
    const _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "ngx-timepicker-period-selector", 9);
    ɵngcc0.ɵɵlistener("periodSelected", function NgxTimepickerFieldComponent_ngx_timepicker_period_selector_7_Template_ngx_timepicker_period_selector_periodSelected_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); const ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.changePeriod($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("selectedPeriod", ctx_r0.period)("disabled", ctx_r0.disabled || ctx_r0.isChangePeriodDisabled);
} }
function NgxTimepickerFieldComponent_ngx_material_timepicker_toggle_8_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
const _c12 = function (a0) { return { "ngx-timepicker__toggle--left": a0 }; };
function NgxTimepickerFieldComponent_ngx_material_timepicker_toggle_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "ngx-material-timepicker-toggle", 10);
    ɵngcc0.ɵɵelementStart(1, "span", 11);
    ɵngcc0.ɵɵtemplate(2, NgxTimepickerFieldComponent_ngx_material_timepicker_toggle_8_ng_container_2_Template, 1, 0, "ng-container", 12);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    const _r2 = ɵngcc0.ɵɵreference(10);
    const _r3 = ɵngcc0.ɵɵreference(12);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(4, _c12, ctx_r1.buttonAlign === "left"))("for", _r2)("disabled", ctx_r1.disabled);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r1.toggleIcon || _r3);
} }
function NgxTimepickerFieldComponent_ng_template_11_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "svg", 13);
    ɵngcc0.ɵɵelement(1, "path", 14);
    ɵngcc0.ɵɵelementEnd();
} }
const _c13 = function (a0) { return { "ngx-timepicker--disabled": a0 }; };
const _c14 = function (a0) { return { "ngx-timepicker-control--active": a0 }; };
const _c15 = function (a0) { return { "period-selector__button--active": a0 }; };
function NgxTimepickerPeriodSelectorComponent_ul_7_Template(rf, ctx) { if (rf & 1) {
    const _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "ul", 6);
    ɵngcc0.ɵɵelementStart(1, "li");
    ɵngcc0.ɵɵelementStart(2, "button", 7);
    ɵngcc0.ɵɵlistener("click", function NgxTimepickerPeriodSelectorComponent_ul_7_Template_button_click_2_listener() { ɵngcc0.ɵɵrestoreView(_r3); const ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.select(ctx_r2.period.AM); });
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(4, "li");
    ɵngcc0.ɵɵelementStart(5, "button", 7);
    ɵngcc0.ɵɵlistener("click", function NgxTimepickerPeriodSelectorComponent_ul_7_Template_button_click_5_listener() { ɵngcc0.ɵɵrestoreView(_r3); const ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.select(ctx_r4.period.PM); });
    ɵngcc0.ɵɵtext(6);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@scaleInOut", undefined)("timepickerAutofocus", true);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(6, _c15, ctx_r0.localizedPeriod === ctx_r0.meridiems[0]));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.meridiems[0]);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(8, _c15, ctx_r0.localizedPeriod === ctx_r0.meridiems[1]));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.meridiems[1]);
} }
function NgxTimepickerPeriodSelectorComponent_div_8_Template(rf, ctx) { if (rf & 1) {
    const _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 8);
    ɵngcc0.ɵɵlistener("click", function NgxTimepickerPeriodSelectorComponent_div_8_Template_div_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r6); const ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.backdropClick(); });
    ɵngcc0.ɵɵelementEnd();
} }
const _c16 = function (a0) { return { "period-control__button--disabled": a0 }; };
function NgxMaterialTimepickerContentComponent_div_0_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function NgxMaterialTimepickerContentComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 3);
    ɵngcc0.ɵɵtemplate(1, NgxMaterialTimepickerContentComponent_div_0_ng_container_1_Template, 1, 0, "ng-container", 4);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    const _r3 = ɵngcc0.ɵɵreference(4);
    ɵngcc0.ɵɵproperty("ngxAppendToInput", ctx_r0.inputElement);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r3);
} }
function NgxMaterialTimepickerContentComponent_ng_template_1_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function NgxMaterialTimepickerContentComponent_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, NgxMaterialTimepickerContentComponent_ng_template_1_ng_container_0_Template, 1, 0, "ng-container", 4);
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext();
    const _r3 = ɵngcc0.ɵɵreference(4);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r3);
} }
function NgxMaterialTimepickerContentComponent_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0);
} }
let NgxMaterialTimepickerEventService = class NgxMaterialTimepickerEventService {
    constructor() {
        this.backdropClickSubject = new Subject();
        this.keydownEventSubject = new Subject();
    }
    get backdropClick() {
        return this.backdropClickSubject.asObservable().pipe(shareReplay({ bufferSize: 1, refCount: true }));
    }
    get keydownEvent() {
        return this.keydownEventSubject.asObservable().pipe(shareReplay({ bufferSize: 1, refCount: true }));
    }
    dispatchEvent(event) {
        switch (event.type) {
            case 'click':
                this.backdropClickSubject.next(event);
                break;
            case 'keydown':
                this.keydownEventSubject.next(event);
                break;
            default:
                throw new Error('no such event type');
        }
    }
};
NgxMaterialTimepickerEventService.ɵfac = function NgxMaterialTimepickerEventService_Factory(t) { return new (t || NgxMaterialTimepickerEventService)(); };
NgxMaterialTimepickerEventService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NgxMaterialTimepickerEventService, factory: function (t) { return NgxMaterialTimepickerEventService.ɵfac(t); }, providedIn: 'root' });
NgxMaterialTimepickerEventService.ngInjectableDef = ɵɵdefineInjectable({ factory: function NgxMaterialTimepickerEventService_Factory() { return new NgxMaterialTimepickerEventService(); }, token: NgxMaterialTimepickerEventService, providedIn: "root" });

let DomService = class DomService {
    constructor(cfr, appRef, injector, document) {
        this.cfr = cfr;
        this.appRef = appRef;
        this.injector = injector;
        this.document = document;
    }
    appendTimepickerToBody(timepicker, config) {
        this.componentRef = this.cfr.resolveComponentFactory(timepicker).create(this.injector);
        Object.keys(config).forEach(key => this.componentRef.instance[key] = config[key]);
        this.appRef.attachView(this.componentRef.hostView);
        const domElement = this.componentRef.hostView
            .rootNodes[0];
        this.document.body.appendChild(domElement);
    }
    destroyTimepicker() {
        this.componentRef.destroy();
        this.appRef.detachView(this.componentRef.hostView);
    }
};
DomService.ɵfac = function DomService_Factory(t) { return new (t || DomService)(ɵngcc0.ɵɵinject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵinject(ɵngcc0.ApplicationRef), ɵngcc0.ɵɵinject(ɵngcc0.Injector), ɵngcc0.ɵɵinject(DOCUMENT, 8)); };
DomService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: DomService, factory: function (t) { return DomService.ɵfac(t); }, providedIn: 'root' });
DomService.ctorParameters = () => [
    { type: ComponentFactoryResolver },
    { type: ApplicationRef },
    { type: Injector },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] }
];
DomService.ngInjectableDef = ɵɵdefineInjectable({ factory: function DomService_Factory() { return new DomService(ɵɵinject(ComponentFactoryResolver), ɵɵinject(ApplicationRef), ɵɵinject(INJECTOR), ɵɵinject(DOCUMENT, 8)); }, token: DomService, providedIn: "root" });
DomService = __decorate([ __param(3, Optional()), __param(3, Inject(DOCUMENT))
], DomService);

var TimeUnit;
(function (TimeUnit) {
    TimeUnit[TimeUnit["HOUR"] = 0] = "HOUR";
    TimeUnit[TimeUnit["MINUTE"] = 1] = "MINUTE";
})(TimeUnit || (TimeUnit = {}));

var TimePeriod;
(function (TimePeriod) {
    TimePeriod["AM"] = "AM";
    TimePeriod["PM"] = "PM";
})(TimePeriod || (TimePeriod = {}));

var TimeFormat;
(function (TimeFormat) {
    TimeFormat["TWELVE"] = "hh:mm a";
    TimeFormat["TWELVE_SHORT"] = "h:m a";
    TimeFormat["TWENTY_FOUR"] = "HH:mm";
    TimeFormat["TWENTY_FOUR_SHORT"] = "H:m";
})(TimeFormat || (TimeFormat = {}));

function isSameOrAfter(time, compareWith, unit = 'minutes') {
    if (unit === 'hours') {
        return time.hour >= compareWith.hour;
    }
    if (unit === 'minutes') {
        return time.hasSame(compareWith, unit) || time.valueOf() > compareWith.valueOf();
    }
}
function isSameOrBefore(time, compareWith, unit = 'minutes') {
    if (unit === 'hours') {
        return time.hour <= compareWith.hour;
    }
    if (unit === 'minutes') {
        return time.hasSame(compareWith, unit) || time.valueOf() <= compareWith.valueOf();
    }
}
function isBetween(time, before, after, unit = 'minutes') {
    if (unit === 'hours') {
        return isSameOrBefore(time, after, unit) && isSameOrAfter(time, before, unit);
    }
    if (unit === 'minutes') {
        return isSameOrBefore(time, after) && isSameOrAfter(time, before);
    }
}
function isDigit(e) {
    // Allow: backspace, delete, tab, escape, enter
    if ([46, 8, 9, 27, 13].some(n => n === e.keyCode) ||
        // Allow: Ctrl/cmd+A
        (e.keyCode == 65 && (e.ctrlKey === true || e.metaKey === true)) ||
        // Allow: Ctrl/cmd+C
        (e.keyCode == 67 && (e.ctrlKey === true || e.metaKey === true)) ||
        // Allow: Ctrl/cmd+X
        (e.keyCode == 88 && (e.ctrlKey === true || e.metaKey === true)) ||
        // Allow: home, end, left, right, up, down
        (e.keyCode >= 35 && e.keyCode <= 40)) {
        return true;
    }
    return !((e.keyCode < 48 || e.keyCode > 57) && (e.keyCode < 96 || e.keyCode > 105));
}

// @dynamic
class TimeAdapter {
    static parseTime(time, opts) {
        const { numberingSystem, locale } = TimeAdapter.getLocaleOptionsByTime(time, opts);
        const isPeriodExist = time.split(' ').length === 2;
        const timeMask = isPeriodExist ? TimeFormat.TWELVE_SHORT : TimeFormat.TWENTY_FOUR_SHORT;
        return DateTime.fromFormat(time, timeMask, { numberingSystem, locale });
    }
    static formatTime(time, opts) {
        if (!time) {
            return 'Invalid Time';
        }
        const { format } = opts;
        const parsedTime = TimeAdapter.parseTime(time, opts).setLocale(TimeAdapter.DEFAULT_LOCALE);
        if (format !== 24) {
            return parsedTime.toLocaleString(Object.assign({}, DateTime.TIME_SIMPLE, { hour12: format !== 24, numberingSystem: TimeAdapter.DEFAULT_NUMBERING_SYSTEM })).replace(/\u200E/g, '');
        }
        return parsedTime.toISOTime({
            includeOffset: false,
            suppressMilliseconds: true,
            suppressSeconds: true
        }).replace(/\u200E/g, '');
    }
    static toLocaleTimeString(time, opts = {}) {
        const { format = TimeAdapter.DEFAULT_FORMAT, locale = TimeAdapter.DEFAULT_LOCALE } = opts;
        const hourCycle = format === 24 ? 'h23' : 'h12';
        const timeFormat = Object.assign({}, DateTime.TIME_SIMPLE, { hourCycle });
        const timeMask = (format === 24) ? TimeFormat.TWENTY_FOUR_SHORT : TimeFormat.TWELVE_SHORT;
        return DateTime.fromFormat(time, timeMask).setLocale(locale).toLocaleString(timeFormat);
    }
    static isTimeAvailable(time, min, max, granularity, minutesGap, format) {
        if (!time) {
            return;
        }
        const convertedTime = this.parseTime(time, { format });
        const minutes = convertedTime.minute;
        if (minutesGap && minutes === minutes && minutes % minutesGap !== 0) {
            throw new Error(`Your minutes - ${minutes} doesn\'t match your minutesGap - ${minutesGap}`);
        }
        const isAfter = (min && !max)
            && isSameOrAfter(convertedTime, min, granularity);
        const isBefore = (max && !min)
            && isSameOrBefore(convertedTime, max, granularity);
        const between = (min && max)
            && isBetween(convertedTime, min, max, granularity);
        const isAvailable = !min && !max;
        return isAfter || isBefore || between || isAvailable;
    }
    /***
     *  Format hour according to time format (12 or 24)
     */
    static formatHour(currentHour, format, period) {
        if (format === 24) {
            return currentHour;
        }
        const hour = period === TimePeriod.AM ? currentHour : currentHour + 12;
        if (period === TimePeriod.AM && hour === 12) {
            return 0;
        }
        else if (period === TimePeriod.PM && hour === 24) {
            return 12;
        }
        return hour;
    }
    static fromDateTimeToString(time, format) {
        const timeFormat = format === 24 ? TimeFormat.TWENTY_FOUR : TimeFormat.TWELVE;
        return time.reconfigure({
            numberingSystem: TimeAdapter.DEFAULT_NUMBERING_SYSTEM,
            locale: TimeAdapter.DEFAULT_LOCALE
        }).toFormat(timeFormat);
    }
    static getLocaleOptionsByTime(time, opts) {
        const { numberingSystem, locale } = DateTime.local().setLocale(opts.locale).resolvedLocaleOpts();
        const localeConfig = { numberingSystem: numberingSystem, locale };
        const defaultConfig = { numberingSystem: TimeAdapter.DEFAULT_NUMBERING_SYSTEM, locale: TimeAdapter.DEFAULT_LOCALE };
        return isNaN(parseInt(time, 10)) ? localeConfig : defaultConfig;
    }
}
TimeAdapter.DEFAULT_FORMAT = 12;
TimeAdapter.DEFAULT_LOCALE = 'en-US';
TimeAdapter.DEFAULT_NUMBERING_SYSTEM = 'latn';

const DEFAULT_HOUR = {
    time: 12,
    angle: 360
};
const DEFAULT_MINUTE = {
    time: 0,
    angle: 360
};
let NgxMaterialTimepickerService = class NgxMaterialTimepickerService {
    constructor() {
        this.hourSubject = new BehaviorSubject(DEFAULT_HOUR);
        this.minuteSubject = new BehaviorSubject(DEFAULT_MINUTE);
        this.periodSubject = new BehaviorSubject(TimePeriod.AM);
    }
    set hour(hour) {
        this.hourSubject.next(hour);
    }
    get selectedHour() {
        return this.hourSubject.asObservable();
    }
    set minute(minute) {
        this.minuteSubject.next(minute);
    }
    get selectedMinute() {
        return this.minuteSubject.asObservable();
    }
    set period(period) {
        const isPeriodValid = (period === TimePeriod.AM) || (period === TimePeriod.PM);
        if (isPeriodValid) {
            this.periodSubject.next(period);
        }
    }
    get selectedPeriod() {
        return this.periodSubject.asObservable();
    }
    setDefaultTimeIfAvailable(time, min, max, format, minutesGap) {
        /* Workaround to double error message*/
        try {
            if (TimeAdapter.isTimeAvailable(time, min, max, 'minutes', minutesGap)) {
                this.setDefaultTime(time, format);
            }
        }
        catch (e) {
            console.error(e);
        }
    }
    getFullTime(format) {
        const selectedHour = this.hourSubject.getValue().time;
        const selectedMinute = this.minuteSubject.getValue().time;
        const hour = selectedHour != null ? selectedHour : DEFAULT_HOUR.time;
        const minute = selectedMinute != null ? selectedMinute : DEFAULT_MINUTE.time;
        const period = format === 12 ? this.periodSubject.getValue() : '';
        const time = `${hour}:${minute} ${period}`.trim();
        return TimeAdapter.formatTime(time, { format });
    }
    setDefaultTime(time, format) {
        const defaultTime = TimeAdapter.parseTime(time, { format }).toJSDate();
        if (DateTime.fromJSDate(defaultTime).isValid) {
            const period = time.substr(time.length - 2).toUpperCase();
            const hour = defaultTime.getHours();
            this.hour = Object.assign({}, DEFAULT_HOUR, { time: formatHourByPeriod(hour, period) });
            this.minute = Object.assign({}, DEFAULT_MINUTE, { time: defaultTime.getMinutes() });
            this.period = period;
        }
        else {
            this.resetTime();
        }
    }
    resetTime() {
        this.hour = Object.assign({}, DEFAULT_HOUR);
        this.minute = Object.assign({}, DEFAULT_MINUTE);
        this.period = TimePeriod.AM;
    }
};
NgxMaterialTimepickerService.ɵfac = function NgxMaterialTimepickerService_Factory(t) { return new (t || NgxMaterialTimepickerService)(); };
NgxMaterialTimepickerService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NgxMaterialTimepickerService, factory: function (t) { return NgxMaterialTimepickerService.ɵfac(t); }, providedIn: 'root' });
NgxMaterialTimepickerService.ngInjectableDef = ɵɵdefineInjectable({ factory: function NgxMaterialTimepickerService_Factory() { return new NgxMaterialTimepickerService(); }, token: NgxMaterialTimepickerService, providedIn: "root" });
/***
 *  Format hour in 24hours format to meridian (AM or PM) format
 */
function formatHourByPeriod(hour, period) {
    switch (period) {
        case TimePeriod.AM:
            return hour === 0 ? 12 : hour;
        case TimePeriod.PM:
            return hour === 12 ? 12 : hour - 12;
        default:
            return hour;
    }
}

const TIME_LOCALE = new InjectionToken('TimeLocale', {
    providedIn: 'root',
    factory: () => TimeAdapter.DEFAULT_LOCALE
});

var AnimationState;
(function (AnimationState) {
    AnimationState["ENTER"] = "enter";
    AnimationState["LEAVE"] = "leave";
})(AnimationState || (AnimationState = {}));
let NgxMaterialTimepickerContainerComponent = class NgxMaterialTimepickerContainerComponent {
    constructor(timepickerService, eventService, locale) {
        this.timepickerService = timepickerService;
        this.eventService = eventService;
        this.locale = locale;
        this.timeUnit = TimeUnit;
        this.activeTimeUnit = TimeUnit.HOUR;
        this.unsubscribe = new Subject();
    }
    set defaultTime(time) {
        this._defaultTime = time;
        this.setDefaultTime(time);
    }
    get defaultTime() {
        return this._defaultTime;
    }
    onKeydown(e) {
        this.eventService.dispatchEvent(e);
        e.stopPropagation();
    }
    ngOnInit() {
        this.animationState = !this.disableAnimation && AnimationState.ENTER;
        this.defineTime();
        this.selectedHour = this.timepickerService.selectedHour
            .pipe(shareReplay({ bufferSize: 1, refCount: true }));
        this.selectedMinute = this.timepickerService.selectedMinute
            .pipe(shareReplay({ bufferSize: 1, refCount: true }));
        this.selectedPeriod = this.timepickerService.selectedPeriod
            .pipe(shareReplay({ bufferSize: 1, refCount: true }));
        this.timepickerBaseRef.timeUpdated.pipe(takeUntil(this.unsubscribe))
            .subscribe(this.setDefaultTime.bind(this));
    }
    onHourChange(hour) {
        this.timepickerService.hour = hour;
        this.onTimeChange();
    }
    onHourSelected(hour) {
        if (!this.hoursOnly) {
            this.changeTimeUnit(TimeUnit.MINUTE);
        }
        this.timepickerBaseRef.hourSelected.next(hour);
    }
    onMinuteChange(minute) {
        this.timepickerService.minute = minute;
        this.onTimeChange();
    }
    changePeriod(period) {
        this.timepickerService.period = period;
        this.onTimeChange();
    }
    changeTimeUnit(unit) {
        this.activeTimeUnit = unit;
    }
    setTime() {
        this.timepickerBaseRef.timeSet.next(this.timepickerService.getFullTime(this.format));
        this.close();
    }
    close() {
        if (this.disableAnimation) {
            this.timepickerBaseRef.close();
            return;
        }
        this.animationState = AnimationState.LEAVE;
    }
    animationDone(event) {
        if (event.phaseName === 'done' && event.toState === AnimationState.LEAVE) {
            this.timepickerBaseRef.close();
        }
    }
    ngOnDestroy() {
        this.unsubscribe.next();
        this.unsubscribe.complete();
    }
    setDefaultTime(time) {
        this.timepickerService.setDefaultTimeIfAvailable(time, this.minTime, this.maxTime, this.format, this.minutesGap);
    }
    defineTime() {
        const minTime = this.minTime;
        if (minTime && (!this.time && !this.defaultTime)) {
            const time = TimeAdapter.fromDateTimeToString(minTime, this.format);
            this.setDefaultTime(time);
        }
    }
    onTimeChange() {
        const time = TimeAdapter.toLocaleTimeString(this.timepickerService.getFullTime(this.format), {
            locale: this.locale,
            format: this.format
        });
        this.timepickerBaseRef.timeChanged.emit(time);
    }
};
NgxMaterialTimepickerContainerComponent.ɵfac = function NgxMaterialTimepickerContainerComponent_Factory(t) { return new (t || NgxMaterialTimepickerContainerComponent)(ɵngcc0.ɵɵdirectiveInject(NgxMaterialTimepickerService), ɵngcc0.ɵɵdirectiveInject(NgxMaterialTimepickerEventService), ɵngcc0.ɵɵdirectiveInject(TIME_LOCALE)); };
NgxMaterialTimepickerContainerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NgxMaterialTimepickerContainerComponent, selectors: [["ngx-material-timepicker-container"]], hostBindings: function NgxMaterialTimepickerContainerComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown", function NgxMaterialTimepickerContainerComponent_keydown_HostBindingHandler($event) { return ctx.onKeydown($event); });
    } }, inputs: { defaultTime: "defaultTime" }, features: [ɵngcc0.ɵɵProvidersFeature([NgxMaterialTimepickerService])], decls: 22, vars: 31, consts: [[1, "timepicker-backdrop-overlay", 3, "overlay", "ngClass"], [1, "timepicker-overlay"], [3, "appendToInput", "inputElement", "ngxMaterialTimepickerTheme"], [1, "timepicker", 3, "ngClass"], [1, "timepicker__header"], [3, "format", "hour", "minute", "period", "activeTimeUnit", "minTime", "maxTime", "isEditable", "editableHintTmpl", "minutesGap", "hoursOnly", "periodChanged", "timeUnitChanged", "hourChanged", "minuteChanged"], [1, "timepicker__main-content"], [1, "timepicker__body", 3, "ngSwitch"], [4, "ngSwitchCase"], [3, "selectedMinute", "selectedHour", "minTime", "maxTime", "format", "period", "minutesGap", "minuteChange", 4, "ngSwitchCase"], [1, "timepicker__actions"], [3, "click"], [4, "ngTemplateOutlet"], ["cancelBtnDefault", ""], ["confirmBtnDefault", ""], [3, "selectedHour", "minTime", "maxTime", "format", "hourChange", "hourSelected", 4, "ngIf", "ngIfElse"], ["ampmHours", ""], [3, "selectedHour", "minTime", "maxTime", "format", "hourChange", "hourSelected"], [3, "selectedHour", "period", "minTime", "maxTime", "hourChange", "hourSelected"], [3, "selectedMinute", "selectedHour", "minTime", "maxTime", "format", "period", "minutesGap", "minuteChange"]], template: function NgxMaterialTimepickerContainerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵelementStart(2, "ngx-material-timepicker-content", 2);
        ɵngcc0.ɵɵelementStart(3, "div", 3);
        ɵngcc0.ɵɵlistener("@timepicker.done", function NgxMaterialTimepickerContainerComponent_Template_div_animation_timepicker_done_3_listener($event) { return ctx.animationDone($event); });
        ɵngcc0.ɵɵelementStart(4, "header", 4);
        ɵngcc0.ɵɵelementStart(5, "ngx-material-timepicker-dial", 5);
        ɵngcc0.ɵɵlistener("periodChanged", function NgxMaterialTimepickerContainerComponent_Template_ngx_material_timepicker_dial_periodChanged_5_listener($event) { return ctx.changePeriod($event); })("timeUnitChanged", function NgxMaterialTimepickerContainerComponent_Template_ngx_material_timepicker_dial_timeUnitChanged_5_listener($event) { return ctx.changeTimeUnit($event); })("hourChanged", function NgxMaterialTimepickerContainerComponent_Template_ngx_material_timepicker_dial_hourChanged_5_listener($event) { return ctx.onHourChange($event); })("minuteChanged", function NgxMaterialTimepickerContainerComponent_Template_ngx_material_timepicker_dial_minuteChanged_5_listener($event) { return ctx.onMinuteChange($event); });
        ɵngcc0.ɵɵpipe(6, "async");
        ɵngcc0.ɵɵpipe(7, "async");
        ɵngcc0.ɵɵpipe(8, "async");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(9, "div", 6);
        ɵngcc0.ɵɵelementStart(10, "div", 7);
        ɵngcc0.ɵɵtemplate(11, NgxMaterialTimepickerContainerComponent_div_11_Template, 4, 2, "div", 8);
        ɵngcc0.ɵɵtemplate(12, NgxMaterialTimepickerContainerComponent_ngx_material_timepicker_minutes_face_12_Template, 4, 13, "ngx-material-timepicker-minutes-face", 9);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(13, "div", 10);
        ɵngcc0.ɵɵelementStart(14, "div", 11);
        ɵngcc0.ɵɵlistener("click", function NgxMaterialTimepickerContainerComponent_Template_div_click_14_listener() { return ctx.close(); });
        ɵngcc0.ɵɵtemplate(15, NgxMaterialTimepickerContainerComponent_ng_container_15_Template, 1, 0, "ng-container", 12);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(16, "div", 11);
        ɵngcc0.ɵɵlistener("click", function NgxMaterialTimepickerContainerComponent_Template_div_click_16_listener() { return ctx.setTime(); });
        ɵngcc0.ɵɵtemplate(17, NgxMaterialTimepickerContainerComponent_ng_container_17_Template, 1, 0, "ng-container", 12);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(18, NgxMaterialTimepickerContainerComponent_ng_template_18_Template, 2, 0, "ng-template", null, 13, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(20, NgxMaterialTimepickerContainerComponent_ng_template_20_Template, 2, 0, "ng-template", null, 14, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        const _r4 = ɵngcc0.ɵɵreference(19);
        const _r6 = ɵngcc0.ɵɵreference(21);
        var tmp_8_0 = null;
        var tmp_9_0 = null;
        ɵngcc0.ɵɵproperty("overlay", ctx.preventOverlayClick)("ngClass", ɵngcc0.ɵɵpureFunction1(29, _c0, ctx.appendToInput));
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("appendToInput", ctx.appendToInput)("inputElement", ctx.inputElement)("ngxMaterialTimepickerTheme", ctx.theme);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("@timepicker", ctx.animationState)("ngClass", ctx.timepickerClass);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("format", ctx.format)("hour", (tmp_8_0 = ɵngcc0.ɵɵpipeBind1(6, 23, ctx.selectedHour)) == null ? null : tmp_8_0.time)("minute", (tmp_9_0 = ɵngcc0.ɵɵpipeBind1(7, 25, ctx.selectedMinute)) == null ? null : tmp_9_0.time)("period", ɵngcc0.ɵɵpipeBind1(8, 27, ctx.selectedPeriod))("activeTimeUnit", ctx.activeTimeUnit)("minTime", ctx.minTime)("maxTime", ctx.maxTime)("isEditable", ctx.enableKeyboardInput)("editableHintTmpl", ctx.editableHintTmpl)("minutesGap", ctx.minutesGap)("hoursOnly", ctx.hoursOnly);
        ɵngcc0.ɵɵadvance(5);
        ɵngcc0.ɵɵproperty("ngSwitch", ctx.activeTimeUnit);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", ctx.timeUnit.HOUR);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", ctx.timeUnit.MINUTE);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.cancelBtnTmpl ? ctx.cancelBtnTmpl : _r4);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.confirmBtnTmpl ? ctx.confirmBtnTmpl : _r6);
    } }, directives: function () { return [OverlayDirective, ɵngcc1.NgClass, NgxMaterialTimepickerContentComponent, NgxMaterialTimepickerThemeDirective, NgxMaterialTimepickerDialComponent, ɵngcc1.NgSwitch, ɵngcc1.NgSwitchCase, ɵngcc1.NgTemplateOutlet, ɵngcc1.NgIf, NgxMaterialTimepicker24HoursFaceComponent, NgxMaterialTimepicker12HoursFaceComponent, NgxMaterialTimepickerMinutesFaceComponent, NgxMaterialTimepickerButtonComponent]; }, pipes: function () { return [ɵngcc1.AsyncPipe]; }, styles: ["[_nghost-%COMP%]{--body-background-color:#fff;--primary-font-family:'Roboto',sans-serif;--button-color:deepskyblue;--dial-active-color:#fff;--dial-inactive-color:rgba(255, 255, 255, .5);--dial-background-color:deepskyblue;--dial-editable-active-color:deepskyblue;--dial-editable-background-color:#fff;--clock-face-time-active-color:#fff;--clock-face-time-inactive-color:#6c6c6c;--clock-face-inner-time-inactive-color:#929292;--clock-face-time-disabled-color:#c5c5c5;--clock-face-background-color:#f0f0f0;--clock-hand-color:deepskyblue}.timepicker-backdrop-overlay[_ngcontent-%COMP%]{position:fixed;top:0;bottom:0;right:0;left:0;background-color:rgba(0,0,0,.3);z-index:999;pointer-events:auto}.timepicker-backdrop-overlay--transparent[_ngcontent-%COMP%]{background-color:transparent}.timepicker-overlay[_ngcontent-%COMP%]{position:fixed;top:0;left:0;width:100%;height:100%;display:flex;justify-content:center;align-items:center;z-index:999;pointer-events:none}.timepicker[_ngcontent-%COMP%]{width:300px;border-radius:2px;box-shadow:rgba(0,0,0,.25) 0 14px 45px,rgba(0,0,0,.22) 0 10px 18px;outline:0;position:static;z-index:999;pointer-events:auto}.timepicker__header[_ngcontent-%COMP%]{padding:15px 30px;background-color:#00bfff}@supports (background-color:var(--dial-background-color)){.timepicker__header[_ngcontent-%COMP%]{background-color:var(--dial-background-color)}}.timepicker__body[_ngcontent-%COMP%]{padding:15px 5px;display:flex;justify-content:center;align-items:center;background-color:#fff}@supports (background-color:var(--body-background-color)){.timepicker__body[_ngcontent-%COMP%]{background-color:var(--body-background-color)}}.timepicker__actions[_ngcontent-%COMP%]{display:flex;justify-content:flex-end;padding:15px;background-color:#fff}@supports (background-color:var(--body-background-color)){.timepicker__actions[_ngcontent-%COMP%]{background-color:var(--body-background-color)}}@media (max-device-width:1023px) and (orientation:landscape){.timepicker[_ngcontent-%COMP%]{display:flex;width:515px}.timepicker__header[_ngcontent-%COMP%]{display:flex;align-items:center}.timepicker__main-content[_ngcontent-%COMP%]{display:flex;flex-direction:column;width:100%}.timepicker__actions[_ngcontent-%COMP%]{padding:5px;margin-top:-1px}}"], data: { animation: [
            trigger('timepicker', [
                transition(`* => ${AnimationState.ENTER}`, [
                    style({ transform: 'translateY(-30%)' }),
                    animate('0.2s ease-out', style({ transform: 'translateY(0)' }))
                ]),
                transition(`${AnimationState.ENTER} => ${AnimationState.LEAVE}`, [
                    style({ transform: 'translateY(0)', opacity: 1 }),
                    animate('0.2s ease-out', style({ transform: 'translateY(-30%)', opacity: 0 }))
                ])
            ])
        ] } });
NgxMaterialTimepickerContainerComponent.ctorParameters = () => [
    { type: NgxMaterialTimepickerService },
    { type: NgxMaterialTimepickerEventService },
    { type: String, decorators: [{ type: Inject, args: [TIME_LOCALE,] }] }
];
__decorate([
    Input()
], NgxMaterialTimepickerContainerComponent.prototype, "defaultTime", null);
__decorate([
    HostListener('keydown', ['$event'])
], NgxMaterialTimepickerContainerComponent.prototype, "onKeydown", null);
NgxMaterialTimepickerContainerComponent = __decorate([ __param(2, Inject(TIME_LOCALE))
], NgxMaterialTimepickerContainerComponent);

const ESCAPE = 27;
let NgxMaterialTimepickerComponent = class NgxMaterialTimepickerComponent {
    constructor(eventService, domService) {
        this.eventService = eventService;
        this.domService = domService;
        this.timeUpdated = new Subject();
        this.isEsc = true;
        this.hoursOnly = false;
        this.timeSet = new EventEmitter();
        this.opened = new EventEmitter();
        this.closed = new EventEmitter();
        this.hourSelected = new EventEmitter();
        this.timeChanged = new EventEmitter();
        this.unsubscribe = new Subject();
    }
    /**
     * @deprecated Since version 5.1.1. Will be deleted on version 6.0.0. Use @Input() theme instead
     */
    set ngxMaterialTimepickerTheme(theme) {
        console.warn(`'ngxMaterialTimepickerTheme' is deprecated. Use 'theme' instead`);
        this._ngxMaterialTimepickerTheme = theme;
    }
    set format(value) {
        this._format = value === 24 ? 24 : 12;
    }
    get format() {
        return this.timepickerInput ? this.timepickerInput.format : this._format;
    }
    set minutesGap(gap) {
        if (gap == null) {
            return;
        }
        gap = Math.floor(gap);
        this._minutesGap = gap <= 59 ? gap : 1;
    }
    get minutesGap() {
        return this._minutesGap;
    }
    get minTime() {
        return this.timepickerInput ? this.timepickerInput.min : this.min;
    }
    get maxTime() {
        return this.timepickerInput ? this.timepickerInput.max : this.max;
    }
    get disabled() {
        return this.timepickerInput && this.timepickerInput.disabled;
    }
    get time() {
        return this.timepickerInput && this.timepickerInput.value;
    }
    get inputElement() {
        return this.timepickerInput && this.timepickerInput.element;
    }
    /***
     * Register an input with this timepicker.
     * input - The timepicker input to register with this timepicker
     */
    registerInput(input) {
        if (this.timepickerInput) {
            throw Error('A Timepicker can only be associated with a single input.');
        }
        this.timepickerInput = input;
    }
    open() {
        this.domService.appendTimepickerToBody(NgxMaterialTimepickerContainerComponent, {
            timepickerBaseRef: this,
            time: this.time,
            defaultTime: this.defaultTime,
            maxTime: this.maxTime,
            minTime: this.minTime,
            format: this.format,
            minutesGap: this.minutesGap,
            disableAnimation: this.disableAnimation,
            cancelBtnTmpl: this.cancelBtnTmpl,
            confirmBtnTmpl: this.confirmBtnTmpl,
            editableHintTmpl: this.editableHintTmpl,
            disabled: this.disabled,
            enableKeyboardInput: this.enableKeyboardInput,
            preventOverlayClick: this.preventOverlayClick,
            appendToInput: this.appendToInput,
            hoursOnly: this.hoursOnly,
            theme: this.theme || this._ngxMaterialTimepickerTheme,
            timepickerClass: this.timepickerClass,
            inputElement: this.inputElement
        });
        this.opened.next();
        this.subscribeToEvents();
    }
    close() {
        this.domService.destroyTimepicker();
        this.closed.next();
        this.unsubscribeFromEvents();
    }
    updateTime(time) {
        this.timeUpdated.next(time);
    }
    subscribeToEvents() {
        merge(this.eventService.backdropClick, this.eventService.keydownEvent.pipe(filter(e => e.keyCode === ESCAPE && this.isEsc)))
            .pipe(takeUntil(this.unsubscribe))
            .subscribe(() => this.close());
    }
    unsubscribeFromEvents() {
        this.unsubscribe.next();
        this.unsubscribe.complete();
    }
};
NgxMaterialTimepickerComponent.ɵfac = function NgxMaterialTimepickerComponent_Factory(t) { return new (t || NgxMaterialTimepickerComponent)(ɵngcc0.ɵɵdirectiveInject(NgxMaterialTimepickerEventService), ɵngcc0.ɵɵdirectiveInject(DomService)); };
NgxMaterialTimepickerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NgxMaterialTimepickerComponent, selectors: [["ngx-material-timepicker"]], inputs: { isEsc: ["ESC", "isEsc"], hoursOnly: "hoursOnly", ngxMaterialTimepickerTheme: "ngxMaterialTimepickerTheme", format: "format", minutesGap: "minutesGap", cancelBtnTmpl: "cancelBtnTmpl", editableHintTmpl: "editableHintTmpl", confirmBtnTmpl: "confirmBtnTmpl", enableKeyboardInput: "enableKeyboardInput", preventOverlayClick: "preventOverlayClick", disableAnimation: "disableAnimation", appendToInput: "appendToInput", defaultTime: "defaultTime", timepickerClass: "timepickerClass", theme: "theme", min: "min", max: "max" }, outputs: { timeSet: "timeSet", opened: "opened", closed: "closed", hourSelected: "hourSelected", timeChanged: "timeChanged" }, decls: 0, vars: 0, template: function NgxMaterialTimepickerComponent_Template(rf, ctx) { }, encapsulation: 2 });
NgxMaterialTimepickerComponent.ctorParameters = () => [
    { type: NgxMaterialTimepickerEventService },
    { type: DomService }
];
__decorate([
    Input()
], NgxMaterialTimepickerComponent.prototype, "cancelBtnTmpl", void 0);
__decorate([
    Input()
], NgxMaterialTimepickerComponent.prototype, "editableHintTmpl", void 0);
__decorate([
    Input()
], NgxMaterialTimepickerComponent.prototype, "confirmBtnTmpl", void 0);
__decorate([
    Input('ESC')
], NgxMaterialTimepickerComponent.prototype, "isEsc", void 0);
__decorate([
    Input()
], NgxMaterialTimepickerComponent.prototype, "enableKeyboardInput", void 0);
__decorate([
    Input()
], NgxMaterialTimepickerComponent.prototype, "preventOverlayClick", void 0);
__decorate([
    Input()
], NgxMaterialTimepickerComponent.prototype, "disableAnimation", void 0);
__decorate([
    Input()
], NgxMaterialTimepickerComponent.prototype, "appendToInput", void 0);
__decorate([
    Input()
], NgxMaterialTimepickerComponent.prototype, "hoursOnly", void 0);
__decorate([
    Input()
], NgxMaterialTimepickerComponent.prototype, "defaultTime", void 0);
__decorate([
    Input()
], NgxMaterialTimepickerComponent.prototype, "timepickerClass", void 0);
__decorate([
    Input()
], NgxMaterialTimepickerComponent.prototype, "theme", void 0);
__decorate([
    Input()
], NgxMaterialTimepickerComponent.prototype, "min", void 0);
__decorate([
    Input()
], NgxMaterialTimepickerComponent.prototype, "max", void 0);
__decorate([
    Input()
], NgxMaterialTimepickerComponent.prototype, "ngxMaterialTimepickerTheme", null);
__decorate([
    Input()
], NgxMaterialTimepickerComponent.prototype, "format", null);
__decorate([
    Input()
], NgxMaterialTimepickerComponent.prototype, "minutesGap", null);
__decorate([
    Output()
], NgxMaterialTimepickerComponent.prototype, "timeSet", void 0);
__decorate([
    Output()
], NgxMaterialTimepickerComponent.prototype, "opened", void 0);
__decorate([
    Output()
], NgxMaterialTimepickerComponent.prototype, "closed", void 0);
__decorate([
    Output()
], NgxMaterialTimepickerComponent.prototype, "hourSelected", void 0);
__decorate([
    Output()
], NgxMaterialTimepickerComponent.prototype, "timeChanged", void 0);

/* To override a default toggle icon */
let NgxMaterialTimepickerToggleIconDirective = class NgxMaterialTimepickerToggleIconDirective {
};
NgxMaterialTimepickerToggleIconDirective.ɵfac = function NgxMaterialTimepickerToggleIconDirective_Factory(t) { return new (t || NgxMaterialTimepickerToggleIconDirective)(); };
NgxMaterialTimepickerToggleIconDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NgxMaterialTimepickerToggleIconDirective, selectors: [["", "ngxMaterialTimepickerToggleIcon", ""]] });

let NgxMaterialTimepickerToggleComponent = class NgxMaterialTimepickerToggleComponent {
    get disabled() {
        return this._disabled === undefined ? this.timepicker.disabled : this._disabled;
    }
    set disabled(value) {
        this._disabled = value;
    }
    open(event) {
        if (this.timepicker) {
            this.timepicker.open();
            event.stopPropagation();
        }
    }
};
NgxMaterialTimepickerToggleComponent.ɵfac = function NgxMaterialTimepickerToggleComponent_Factory(t) { return new (t || NgxMaterialTimepickerToggleComponent)(); };
NgxMaterialTimepickerToggleComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NgxMaterialTimepickerToggleComponent, selectors: [["ngx-material-timepicker-toggle"]], contentQueries: function NgxMaterialTimepickerToggleComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵstaticContentQuery(dirIndex, NgxMaterialTimepickerToggleIconDirective, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.customIcon = _t.first);
    } }, inputs: { disabled: "disabled", timepicker: ["for", "timepicker"] }, ngContentSelectors: _c2, decls: 3, vars: 2, consts: [["type", "button", 1, "ngx-material-timepicker-toggle", 3, "disabled", "click"], ["xmlns", "http://www.w3.org/2000/svg", "viewBox", "0 0 24 24", "width", "24px", "height", "24px", 4, "ngIf"], ["xmlns", "http://www.w3.org/2000/svg", "viewBox", "0 0 24 24", "width", "24px", "height", "24px"], ["d", "M 12 2 C 6.4889971 2 2 6.4889971 2 12 C 2 17.511003                   6.4889971 22 12 22 C 17.511003 22 22 17.511003 22 12 C 22 6.4889971 17.511003 2 12 2 z M 12 4 C 16.430123 4 20 7.5698774 20 12 C 20 16.430123 16.430123 20 12 20 C 7.5698774 20 4 16.430123 4 12 C 4 7.5698774 7.5698774 4 12 4 z M 11 6 L 11 12.414062 L 15.292969 16.707031 L 16.707031 15.292969 L 13 11.585938 L 13 6 L 11 6 z"]], template: function NgxMaterialTimepickerToggleComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c1);
        ɵngcc0.ɵɵelementStart(0, "button", 0);
        ɵngcc0.ɵɵlistener("click", function NgxMaterialTimepickerToggleComponent_Template_button_click_0_listener($event) { return ctx.open($event); });
        ɵngcc0.ɵɵtemplate(1, NgxMaterialTimepickerToggleComponent__svg_svg_1_Template, 2, 0, "svg", 1);
        ɵngcc0.ɵɵprojection(2);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("disabled", ctx.disabled);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.customIcon);
    } }, directives: [ɵngcc1.NgIf], styles: [".ngx-material-timepicker-toggle[_ngcontent-%COMP%]{display:flex;justify-content:center;align-items:center;padding:4px;background-color:transparent;border-radius:50%;text-align:center;border:none;outline:0;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:background-color .3s;cursor:pointer}.ngx-material-timepicker-toggle[_ngcontent-%COMP%]:focus{background-color:rgba(0,0,0,.07)}"] });
__decorate([
    Input('for')
], NgxMaterialTimepickerToggleComponent.prototype, "timepicker", void 0);
__decorate([
    Input()
], NgxMaterialTimepickerToggleComponent.prototype, "disabled", null);
__decorate([
    ContentChild(NgxMaterialTimepickerToggleIconDirective, { static: true })
], NgxMaterialTimepickerToggleComponent.prototype, "customIcon", void 0);

var TimepickerDirective_1;
let TimepickerDirective = TimepickerDirective_1 = class TimepickerDirective {
    constructor(elementRef, locale) {
        this.elementRef = elementRef;
        this.locale = locale;
        this._format = 12;
        this._value = '';
        this.timepickerSubscriptions = [];
        this.onTouched = () => {
        };
        this.onChange = () => {
        };
    }
    set format(value) {
        this._format = value === 24 ? 24 : 12;
        const isDynamicallyChanged = value && (this.previousFormat && this.previousFormat !== this._format);
        if (isDynamicallyChanged) {
            this.value = this._value;
            this._timepicker.updateTime(this._value);
        }
        this.previousFormat = this._format;
    }
    get format() {
        return this._format;
    }
    set min(value) {
        if (typeof value === 'string') {
            this._min = TimeAdapter.parseTime(value, { locale: this.locale, format: this.format });
            return;
        }
        this._min = value;
    }
    get min() {
        return this._min;
    }
    set max(value) {
        if (typeof value === 'string') {
            this._max = TimeAdapter.parseTime(value, { locale: this.locale, format: this.format });
            return;
        }
        this._max = value;
    }
    get max() {
        return this._max;
    }
    set timepicker(picker) {
        this.registerTimepicker(picker);
    }
    set value(value) {
        if (!value) {
            this._value = '';
            this.updateInputValue();
            return;
        }
        const time = TimeAdapter.formatTime(value, { locale: this.locale, format: this.format });
        const isAvailable = TimeAdapter.isTimeAvailable(time, this._min, this._max, 'minutes', this._timepicker.minutesGap, this._format);
        if (isAvailable) {
            this._value = time;
            this.updateInputValue();
            return;
        }
        console.warn('Selected time doesn\'t match min or max value');
    }
    get value() {
        if (!this._value) {
            return '';
        }
        return TimeAdapter.toLocaleTimeString(this._value, { format: this.format, locale: this.locale });
    }
    get element() {
        return this.elementRef && this.elementRef.nativeElement;
    }
    set defaultTime(time) {
        this._timepicker.defaultTime = TimeAdapter.formatTime(time, { locale: this.locale, format: this.format });
    }
    updateValue(value) {
        this.value = value;
        this.onChange(value);
    }
    ngOnChanges(changes) {
        if (changes['value'] && changes['value'].currentValue) {
            this.defaultTime = changes['value'].currentValue;
        }
    }
    onClick(event) {
        if (!this.disableClick) {
            this._timepicker.open();
            event.stopPropagation();
        }
    }
    writeValue(value) {
        this.value = value;
        if (value) {
            this.defaultTime = value;
        }
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    ngOnDestroy() {
        this.timepickerSubscriptions.forEach(s => s.unsubscribe());
    }
    registerTimepicker(picker) {
        if (picker) {
            this._timepicker = picker;
            this._timepicker.registerInput(this);
            this.timepickerSubscriptions.push(this._timepicker.timeSet.subscribe((time) => {
                this.value = time;
                this.onChange(this.value);
                this.onTouched();
                this.defaultTime = this._value;
            }));
        }
        else {
            throw new Error('NgxMaterialTimepickerComponent is not defined.' +
                ' Please make sure you passed the timepicker to ngxTimepicker directive');
        }
    }
    updateInputValue() {
        this.elementRef.nativeElement.value = this.value;
    }
};
TimepickerDirective.ɵfac = function TimepickerDirective_Factory(t) { return new (t || TimepickerDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(TIME_LOCALE)); };
TimepickerDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: TimepickerDirective, selectors: [["", "ngxTimepicker", ""]], hostVars: 1, hostBindings: function TimepickerDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("change", function TimepickerDirective_change_HostBindingHandler($event) { return ctx.updateValue($event.target.value); })("blur", function TimepickerDirective_blur_HostBindingHandler() { return ctx.onTouched(); })("click", function TimepickerDirective_click_HostBindingHandler($event) { return ctx.onClick($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵhostProperty("disabled", ctx.disabled);
    } }, inputs: { format: "format", value: "value", min: "min", max: "max", timepicker: ["ngxTimepicker", "timepicker"], disabled: "disabled", disableClick: "disableClick" }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: TimepickerDirective_1,
                multi: true
            }
        ]), ɵngcc0.ɵɵNgOnChangesFeature] });
TimepickerDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: String, decorators: [{ type: Inject, args: [TIME_LOCALE,] }] }
];
__decorate([
    Input()
], TimepickerDirective.prototype, "format", null);
__decorate([
    Input()
], TimepickerDirective.prototype, "min", null);
__decorate([
    Input()
], TimepickerDirective.prototype, "max", null);
__decorate([
    Input('ngxTimepicker')
], TimepickerDirective.prototype, "timepicker", null);
__decorate([
    Input()
], TimepickerDirective.prototype, "value", null);
__decorate([
    Input()
], TimepickerDirective.prototype, "disabled", void 0);
__decorate([
    Input()
], TimepickerDirective.prototype, "disableClick", void 0);
__decorate([
    HostListener('click', ['$event'])
], TimepickerDirective.prototype, "onClick", null);
TimepickerDirective = TimepickerDirective_1 = __decorate([ __param(1, Inject(TIME_LOCALE))
], TimepickerDirective);

let NgxMaterialTimepickerThemeDirective = class NgxMaterialTimepickerThemeDirective {
    constructor(elementRef) {
        this.element = elementRef.nativeElement;
    }
    ngAfterViewInit() {
        if (this.theme) {
            this.setTheme(this.theme);
        }
    }
    setTheme(theme) {
        for (const val in theme) {
            if (theme.hasOwnProperty(val)) {
                if (typeof theme[val] === 'string') {
                    for (const prop in theme) {
                        if (theme.hasOwnProperty(prop)) {
                            this.element.style.setProperty(`--${camelCaseToDash(prop)}`, theme[prop]);
                        }
                    }
                    return;
                }
                this.setTheme(theme[val]);
            }
        }
    }
};
NgxMaterialTimepickerThemeDirective.ɵfac = function NgxMaterialTimepickerThemeDirective_Factory(t) { return new (t || NgxMaterialTimepickerThemeDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
NgxMaterialTimepickerThemeDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NgxMaterialTimepickerThemeDirective, selectors: [["", "ngxMaterialTimepickerTheme", ""]], inputs: { theme: ["ngxMaterialTimepickerTheme", "theme"] } });
NgxMaterialTimepickerThemeDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Input('ngxMaterialTimepickerTheme')
], NgxMaterialTimepickerThemeDirective.prototype, "theme", void 0);
function camelCaseToDash(myStr) {
    return myStr.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
}

// @dynamic
class TimepickerTimeUtils {
    static getHours(format) {
        return Array(format).fill(1).map((v, i) => {
            const angleStep = 30;
            const time = v + i;
            const angle = angleStep * time;
            return { time: time === 24 ? 0 : time, angle };
        });
    }
    static disableHours(hours, config) {
        if (config.min || config.max) {
            return hours.map(value => {
                const hour = config.format === 24 ? value.time : TimeAdapter.formatHour(value.time, config.format, config.period);
                const currentTime = DateTime.fromObject({ hour }).toFormat(TimeFormat.TWELVE);
                return Object.assign({}, value, { disabled: !TimeAdapter.isTimeAvailable(currentTime, config.min, config.max, 'hours') });
            });
        }
        return hours;
    }
    static getMinutes(gap = 1) {
        const minutesCount = 60;
        const angleStep = 360 / minutesCount;
        const minutes = [];
        for (let i = 0; i < minutesCount; i++) {
            const angle = angleStep * i;
            if (i % gap === 0) {
                minutes.push({ time: i, angle: angle !== 0 ? angle : 360 });
            }
        }
        return minutes;
    }
    static disableMinutes(minutes, selectedHour, config) {
        if (config.min || config.max) {
            const hour = TimeAdapter.formatHour(selectedHour, config.format, config.period);
            return minutes.map(value => {
                const currentTime = DateTime.fromObject({ hour, minute: value.time }).toFormat(TimeFormat.TWELVE);
                return Object.assign({}, value, { disabled: !TimeAdapter.isTimeAvailable(currentTime, config.min, config.max, 'minutes') });
            });
        }
        return minutes;
    }
}

class NgxMaterialTimepickerHoursFace {
    constructor(format) {
        this.hourChange = new EventEmitter();
        this.hourSelected = new EventEmitter();
        this.hoursList = [];
        this.hoursList = TimepickerTimeUtils.getHours(format);
    }
    onTimeSelected(time) {
        this.hourSelected.next(time);
    }
}
NgxMaterialTimepickerHoursFace.ɵfac = function NgxMaterialTimepickerHoursFace_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
NgxMaterialTimepickerHoursFace.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NgxMaterialTimepickerHoursFace, inputs: { selectedHour: "selectedHour", minTime: "minTime", maxTime: "maxTime", format: "format" }, outputs: { hourChange: "hourChange", hourSelected: "hourSelected" } });
__decorate([
    Input()
], NgxMaterialTimepickerHoursFace.prototype, "selectedHour", void 0);
__decorate([
    Input()
], NgxMaterialTimepickerHoursFace.prototype, "minTime", void 0);
__decorate([
    Input()
], NgxMaterialTimepickerHoursFace.prototype, "maxTime", void 0);
__decorate([
    Input()
], NgxMaterialTimepickerHoursFace.prototype, "format", void 0);
__decorate([
    Output()
], NgxMaterialTimepickerHoursFace.prototype, "hourChange", void 0);
__decorate([
    Output()
], NgxMaterialTimepickerHoursFace.prototype, "hourSelected", void 0);

let NgxMaterialTimepicker24HoursFaceComponent = class NgxMaterialTimepicker24HoursFaceComponent extends NgxMaterialTimepickerHoursFace {
    constructor() {
        super(24);
    }
    ngAfterContentInit() {
        this.hoursList = TimepickerTimeUtils.disableHours(this.hoursList, {
            min: this.minTime,
            max: this.maxTime,
            format: this.format
        });
    }
};
NgxMaterialTimepicker24HoursFaceComponent.ɵfac = function NgxMaterialTimepicker24HoursFaceComponent_Factory(t) { return new (t || NgxMaterialTimepicker24HoursFaceComponent)(); };
NgxMaterialTimepicker24HoursFaceComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NgxMaterialTimepicker24HoursFaceComponent, selectors: [["ngx-material-timepicker-24-hours-face"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 1, vars: 3, consts: [[3, "selectedTime", "faceTime", "format", "timeChange", "timeSelected"]], template: function NgxMaterialTimepicker24HoursFaceComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-material-timepicker-face", 0);
        ɵngcc0.ɵɵlistener("timeChange", function NgxMaterialTimepicker24HoursFaceComponent_Template_ngx_material_timepicker_face_timeChange_0_listener($event) { return ctx.hourChange.next($event); })("timeSelected", function NgxMaterialTimepicker24HoursFaceComponent_Template_ngx_material_timepicker_face_timeSelected_0_listener($event) { return ctx.onTimeSelected($event); });
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("selectedTime", ctx.selectedHour)("faceTime", ctx.hoursList)("format", ctx.format);
    } }, directives: function () { return [NgxMaterialTimepickerFaceComponent]; }, encapsulation: 2, changeDetection: 0 });

let NgxMaterialTimepicker12HoursFaceComponent = class NgxMaterialTimepicker12HoursFaceComponent extends NgxMaterialTimepickerHoursFace {
    constructor() {
        super(12);
    }
    ngOnChanges(changes) {
        if (changes['period'] && changes['period'].currentValue) {
            this.hoursList = TimepickerTimeUtils.disableHours(this.hoursList, {
                min: this.minTime,
                max: this.maxTime,
                format: this.format,
                period: this.period
            });
        }
    }
};
NgxMaterialTimepicker12HoursFaceComponent.ɵfac = function NgxMaterialTimepicker12HoursFaceComponent_Factory(t) { return new (t || NgxMaterialTimepicker12HoursFaceComponent)(); };
NgxMaterialTimepicker12HoursFaceComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NgxMaterialTimepicker12HoursFaceComponent, selectors: [["ngx-material-timepicker-12-hours-face"]], inputs: { period: "period" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature], decls: 1, vars: 2, consts: [[3, "selectedTime", "faceTime", "timeChange", "timeSelected"]], template: function NgxMaterialTimepicker12HoursFaceComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-material-timepicker-face", 0);
        ɵngcc0.ɵɵlistener("timeChange", function NgxMaterialTimepicker12HoursFaceComponent_Template_ngx_material_timepicker_face_timeChange_0_listener($event) { return ctx.hourChange.next($event); })("timeSelected", function NgxMaterialTimepicker12HoursFaceComponent_Template_ngx_material_timepicker_face_timeSelected_0_listener($event) { return ctx.onTimeSelected($event); });
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("selectedTime", ctx.selectedHour)("faceTime", ctx.hoursList);
    } }, directives: function () { return [NgxMaterialTimepickerFaceComponent]; }, encapsulation: 2, changeDetection: 0 });
__decorate([
    Input()
], NgxMaterialTimepicker12HoursFaceComponent.prototype, "period", void 0);

let NgxMaterialTimepickerMinutesFaceComponent = class NgxMaterialTimepickerMinutesFaceComponent {
    constructor() {
        this.minutesList = [];
        this.timeUnit = TimeUnit;
        this.minuteChange = new EventEmitter();
    }
    ngOnChanges(changes) {
        if (changes['period'] && changes['period'].currentValue) {
            const minutes = TimepickerTimeUtils.getMinutes(this.minutesGap);
            this.minutesList = TimepickerTimeUtils.disableMinutes(minutes, this.selectedHour, {
                min: this.minTime,
                max: this.maxTime,
                format: this.format,
                period: this.period
            });
        }
    }
};
NgxMaterialTimepickerMinutesFaceComponent.ɵfac = function NgxMaterialTimepickerMinutesFaceComponent_Factory(t) { return new (t || NgxMaterialTimepickerMinutesFaceComponent)(); };
NgxMaterialTimepickerMinutesFaceComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NgxMaterialTimepickerMinutesFaceComponent, selectors: [["ngx-material-timepicker-minutes-face"]], inputs: { selectedMinute: "selectedMinute", selectedHour: "selectedHour", period: "period", minTime: "minTime", maxTime: "maxTime", format: "format", minutesGap: "minutesGap" }, outputs: { minuteChange: "minuteChange" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 1, vars: 4, consts: [[3, "faceTime", "selectedTime", "minutesGap", "unit", "timeChange"]], template: function NgxMaterialTimepickerMinutesFaceComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-material-timepicker-face", 0);
        ɵngcc0.ɵɵlistener("timeChange", function NgxMaterialTimepickerMinutesFaceComponent_Template_ngx_material_timepicker_face_timeChange_0_listener($event) { return ctx.minuteChange.next($event); });
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("faceTime", ctx.minutesList)("selectedTime", ctx.selectedMinute)("minutesGap", ctx.minutesGap)("unit", ctx.timeUnit.MINUTE);
    } }, directives: function () { return [NgxMaterialTimepickerFaceComponent]; }, encapsulation: 2 });
__decorate([
    Input()
], NgxMaterialTimepickerMinutesFaceComponent.prototype, "selectedMinute", void 0);
__decorate([
    Input()
], NgxMaterialTimepickerMinutesFaceComponent.prototype, "selectedHour", void 0);
__decorate([
    Input()
], NgxMaterialTimepickerMinutesFaceComponent.prototype, "period", void 0);
__decorate([
    Input()
], NgxMaterialTimepickerMinutesFaceComponent.prototype, "minTime", void 0);
__decorate([
    Input()
], NgxMaterialTimepickerMinutesFaceComponent.prototype, "maxTime", void 0);
__decorate([
    Input()
], NgxMaterialTimepickerMinutesFaceComponent.prototype, "format", void 0);
__decorate([
    Input()
], NgxMaterialTimepickerMinutesFaceComponent.prototype, "minutesGap", void 0);
__decorate([
    Output()
], NgxMaterialTimepickerMinutesFaceComponent.prototype, "minuteChange", void 0);

const CLOCK_HAND_STYLES = {
    small: {
        height: '75px',
        top: 'calc(50% - 75px)'
    },
    large: {
        height: '103px',
        top: 'calc(50% - 103px)'
    }
};
let NgxMaterialTimepickerFaceComponent = class NgxMaterialTimepickerFaceComponent {
    constructor() {
        this.timeUnit = TimeUnit;
        this.innerClockFaceSize = 85;
        this.timeChange = new EventEmitter();
        this.timeSelected = new EventEmitter();
    }
    ngAfterViewInit() {
        this.setClockHandPosition();
        this.addTouchEvents();
    }
    ngOnChanges(changes) {
        const faceTimeChanges = changes['faceTime'];
        const selectedTimeChanges = changes['selectedTime'];
        if ((faceTimeChanges && faceTimeChanges.currentValue)
            && (selectedTimeChanges && selectedTimeChanges.currentValue)) {
            /* Set time according to passed an input value */
            this.selectedTime = this.faceTime.find(time => time.time === this.selectedTime.time);
        }
        if (selectedTimeChanges && selectedTimeChanges.currentValue) {
            this.setClockHandPosition();
        }
        if (faceTimeChanges && faceTimeChanges.currentValue) {
            // To avoid an error ExpressionChangedAfterItHasBeenCheckedError
            setTimeout(() => this.selectAvailableTime());
        }
    }
    trackByTime(_, time) {
        return time.time;
    }
    onMousedown(e) {
        e.preventDefault();
        this.isStarted = true;
    }
    selectTime(e) {
        if (!this.isStarted && (e instanceof MouseEvent && e.type !== 'click')) {
            return;
        }
        const clockFaceCords = this.clockFace.nativeElement.getBoundingClientRect();
        /* Get x0 and y0 of the circle */
        const centerX = clockFaceCords.left + clockFaceCords.width / 2;
        const centerY = clockFaceCords.top + clockFaceCords.height / 2;
        /* Counting the arctangent and convert it to from radian to deg */
        const arctangent = Math.atan(Math.abs(e.clientX - centerX) / Math.abs(e.clientY - centerY)) * 180 / Math.PI;
        /* Get angle according to quadrant */
        const circleAngle = countAngleByCords(centerX, centerY, e.clientX, e.clientY, arctangent);
        /* Check if selected time from the inner clock face (24 hours format only) */
        const isInnerClockChosen = this.format && this.isInnerClockFace(centerX, centerY, e.clientX, e.clientY);
        /* Round angle according to angle step */
        const angleStep = this.unit === TimeUnit.MINUTE ? (6 * (this.minutesGap || 1)) : 30;
        const roundedAngle = roundAngle(circleAngle, angleStep);
        const angle = (roundedAngle || 360) + (isInnerClockChosen ? 360 : 0);
        const selectedTime = this.faceTime.find(val => val.angle === angle);
        if (selectedTime && !selectedTime.disabled) {
            this.timeChange.next(selectedTime);
            /* To let know whether user ended interaction with clock face */
            if (!this.isStarted) {
                this.timeSelected.next(selectedTime.time);
            }
        }
    }
    onMouseup(e) {
        e.preventDefault();
        this.isStarted = false;
    }
    ngOnDestroy() {
        this.removeTouchEvents();
    }
    addTouchEvents() {
        this.touchStartHandler = this.onMousedown.bind(this);
        this.touchEndHandler = this.onMouseup.bind(this);
        this.clockFace.nativeElement.addEventListener('touchstart', this.touchStartHandler);
        this.clockFace.nativeElement.addEventListener('touchend', this.touchEndHandler);
    }
    removeTouchEvents() {
        this.clockFace.nativeElement.removeEventListener('touchstart', this.touchStartHandler);
        this.clockFace.nativeElement.removeEventListener('touchend', this.touchEndHandler);
    }
    setClockHandPosition() {
        if (this.format === 24) {
            if (this.selectedTime.time > 12 || this.selectedTime.time === 0) {
                this.decreaseClockHand();
            }
            else {
                this.increaseClockHand();
            }
        }
        this.clockHand.nativeElement.style.transform = `rotate(${this.selectedTime.angle}deg)`;
    }
    selectAvailableTime() {
        const currentTime = this.faceTime.find(time => this.selectedTime.time === time.time);
        this.isClockFaceDisabled = this.faceTime.every(time => time.disabled);
        if ((currentTime && currentTime.disabled) && !this.isClockFaceDisabled) {
            const availableTime = this.faceTime.find(time => !time.disabled);
            this.timeChange.next(availableTime);
        }
    }
    isInnerClockFace(x0, y0, x, y) {
        /* Detect whether time from the inner clock face or not (24 format only) */
        return Math.sqrt(Math.pow(x - x0, 2) + Math.pow(y - y0, 2)) < this.innerClockFaceSize;
    }
    decreaseClockHand() {
        this.clockHand.nativeElement.style.height = CLOCK_HAND_STYLES.small.height;
        this.clockHand.nativeElement.style.top = CLOCK_HAND_STYLES.small.top;
    }
    increaseClockHand() {
        this.clockHand.nativeElement.style.height = CLOCK_HAND_STYLES.large.height;
        this.clockHand.nativeElement.style.top = CLOCK_HAND_STYLES.large.top;
    }
};
NgxMaterialTimepickerFaceComponent.ɵfac = function NgxMaterialTimepickerFaceComponent_Factory(t) { return new (t || NgxMaterialTimepickerFaceComponent)(); };
NgxMaterialTimepickerFaceComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NgxMaterialTimepickerFaceComponent, selectors: [["ngx-material-timepicker-face"]], viewQuery: function NgxMaterialTimepickerFaceComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c3, true);
        ɵngcc0.ɵɵstaticViewQuery(_c4, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.clockFace = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.clockHand = _t.first);
    } }, hostBindings: function NgxMaterialTimepickerFaceComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mousedown", function NgxMaterialTimepickerFaceComponent_mousedown_HostBindingHandler($event) { return ctx.onMousedown($event); })("click", function NgxMaterialTimepickerFaceComponent_click_HostBindingHandler($event) { return ctx.selectTime($event); })("touchmove", function NgxMaterialTimepickerFaceComponent_touchmove_HostBindingHandler($event) { return ctx.selectTime($event.changedTouches[0]); })("touchend", function NgxMaterialTimepickerFaceComponent_touchend_HostBindingHandler($event) { return ctx.selectTime($event.changedTouches[0]); })("mousemove", function NgxMaterialTimepickerFaceComponent_mousemove_HostBindingHandler($event) { return ctx.selectTime($event); })("mouseup", function NgxMaterialTimepickerFaceComponent_mouseup_HostBindingHandler($event) { return ctx.onMouseup($event); });
    } }, inputs: { selectedTime: "selectedTime", faceTime: "faceTime", unit: "unit", format: "format", minutesGap: "minutesGap" }, outputs: { timeChange: "timeChange", timeSelected: "timeSelected" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 7, vars: 6, consts: [[1, "clock-face"], ["clockFace", ""], ["class", "clock-face__container", 4, "ngIf", "ngIfElse"], [1, "clock-face__clock-hand", 3, "ngClass", "hidden"], ["clockHand", ""], ["minutesFace", ""], [1, "clock-face__container"], ["class", "clock-face__number clock-face__number--outer", 3, "ngStyle", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["class", "clock-face__inner", 3, "top", 4, "ngIf"], [1, "clock-face__number", "clock-face__number--outer", 3, "ngStyle"], [3, "ngStyle", "ngClass"], [1, "clock-face__inner"], ["class", "clock-face__number clock-face__number--inner", 3, "ngStyle", "height", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "clock-face__number", "clock-face__number--inner", 3, "ngStyle"]], template: function NgxMaterialTimepickerFaceComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0, 1);
        ɵngcc0.ɵɵtemplate(2, NgxMaterialTimepickerFaceComponent_div_2_Template, 4, 7, "div", 2);
        ɵngcc0.ɵɵelement(3, "span", 3, 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(5, NgxMaterialTimepickerFaceComponent_ng_template_5_Template, 2, 2, "ng-template", null, 5, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        const _r3 = ɵngcc0.ɵɵreference(6);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.unit !== ctx.timeUnit.MINUTE)("ngIfElse", _r3);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(4, _c7, ctx.unit === ctx.timeUnit.MINUTE))("hidden", ctx.isClockFaceDisabled);
    } }, directives: function () { return [ɵngcc1.NgIf, ɵngcc1.NgClass, ɵngcc1.NgForOf, ɵngcc1.NgStyle]; }, pipes: function () { return [ɵngcc1.SlicePipe, ActiveHourPipe, TimeLocalizerPipe, ActiveMinutePipe, MinutesFormatterPipe]; }, styles: [".clock-face[_ngcontent-%COMP%]{width:290px;height:290px;border-radius:50%;position:relative;display:flex;justify-content:center;padding:20px;box-sizing:border-box;background-color:#f0f0f0}@supports (background-color:var(--clock-face-background-color)){.clock-face[_ngcontent-%COMP%]{background-color:var(--clock-face-background-color)}}.clock-face__inner[_ngcontent-%COMP%]{position:absolute}.clock-face__container[_ngcontent-%COMP%]{margin-left:-2px}.clock-face__number[_ngcontent-%COMP%]{position:absolute;transform-origin:0 100%;width:50px;text-align:center;z-index:2}.clock-face__number--outer[_ngcontent-%COMP%]{height:calc(290px / 2 - 20px)}.clock-face__number--outer[_ngcontent-%COMP%] > span[_ngcontent-%COMP%]{font-size:16px;color:#6c6c6c}@supports (color:var(--clock-face-time-inactive-color)){.clock-face__number--outer[_ngcontent-%COMP%] > span[_ngcontent-%COMP%]{color:var(--clock-face-time-inactive-color)}}.clock-face__number--inner[_ngcontent-%COMP%] > span[_ngcontent-%COMP%]{font-size:14px;color:#929292}@supports (color:var(--clock-face-inner-time-inactive-color)){.clock-face__number--inner[_ngcontent-%COMP%] > span[_ngcontent-%COMP%]{color:var(--clock-face-inner-time-inactive-color)}}.clock-face__number[_ngcontent-%COMP%] > span[_ngcontent-%COMP%]{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:30px;height:30px;display:flex;justify-content:center;align-items:center;margin:auto;border-radius:50%;font-weight:500;font-family:Roboto,sans-serif}@supports (font-family:var(--primary-font-family)){.clock-face__number[_ngcontent-%COMP%] > span[_ngcontent-%COMP%]{font-family:var(--primary-font-family)}}.clock-face__number[_ngcontent-%COMP%] > span.active[_ngcontent-%COMP%]{background-color:#00bfff;color:#fff}@supports (background-color:var(--clock-hand-color)){.clock-face__number[_ngcontent-%COMP%] > span.active[_ngcontent-%COMP%]{background-color:var(--clock-hand-color);color:var(--clock-face-time-active-color)}}.clock-face__number[_ngcontent-%COMP%] > span.disabled[_ngcontent-%COMP%]{color:#c5c5c5}@supports (color:var(--clock-face-time-disabled-color)){.clock-face__number[_ngcontent-%COMP%] > span.disabled[_ngcontent-%COMP%]{color:var(--clock-face-time-disabled-color)}}.clock-face__clock-hand[_ngcontent-%COMP%]{height:103px;width:2px;transform-origin:0 100%;position:absolute;top:calc(50% - 103px);z-index:1;background-color:#00bfff}@supports (background-color:var(--clock-hand-color)){.clock-face__clock-hand[_ngcontent-%COMP%]{background-color:var(--clock-hand-color)}}.clock-face__clock-hand[_ngcontent-%COMP%]:after{content:'';width:7px;height:7px;border-radius:50%;background-color:inherit;position:absolute;bottom:-3px;left:-3.5px}.clock-face__clock-hand_minute[_ngcontent-%COMP%]:before{content:'';width:7px;height:7px;background-color:#fff;border-radius:50%;position:absolute;top:-8px;left:calc(50% - 8px);box-sizing:content-box;border:4px solid #00bfff}@supports (border-color:var(--clock-hand-color)){.clock-face__clock-hand_minute[_ngcontent-%COMP%]:before{border-color:var(--clock-hand-color)}}@media (max-device-width:1023px) and (orientation:landscape){.clock-face[_ngcontent-%COMP%]{width:225px;height:225px;padding:5px}.clock-face__number--outer[_ngcontent-%COMP%]{height:calc(225px / 2 - 5px)}.clock-face__clock-hand_minute[_ngcontent-%COMP%]:before{top:0}}"], changeDetection: 0 });
__decorate([
    Input()
], NgxMaterialTimepickerFaceComponent.prototype, "faceTime", void 0);
__decorate([
    Input()
], NgxMaterialTimepickerFaceComponent.prototype, "selectedTime", void 0);
__decorate([
    Input()
], NgxMaterialTimepickerFaceComponent.prototype, "unit", void 0);
__decorate([
    Input()
], NgxMaterialTimepickerFaceComponent.prototype, "format", void 0);
__decorate([
    Input()
], NgxMaterialTimepickerFaceComponent.prototype, "minutesGap", void 0);
__decorate([
    Output()
], NgxMaterialTimepickerFaceComponent.prototype, "timeChange", void 0);
__decorate([
    Output()
], NgxMaterialTimepickerFaceComponent.prototype, "timeSelected", void 0);
__decorate([
    ViewChild('clockFace', { static: true })
], NgxMaterialTimepickerFaceComponent.prototype, "clockFace", void 0);
__decorate([
    ViewChild('clockHand', { static: true })
], NgxMaterialTimepickerFaceComponent.prototype, "clockHand", void 0);
__decorate([
    HostListener('mousedown', ['$event'])
], NgxMaterialTimepickerFaceComponent.prototype, "onMousedown", null);
__decorate([
    HostListener('click', ['$event']),
    HostListener('touchmove', ['$event.changedTouches[0]']),
    HostListener('touchend', ['$event.changedTouches[0]']),
    HostListener('mousemove', ['$event'])
], NgxMaterialTimepickerFaceComponent.prototype, "selectTime", null);
__decorate([
    HostListener('mouseup', ['$event'])
], NgxMaterialTimepickerFaceComponent.prototype, "onMouseup", null);
function roundAngle(angle, step) {
    return Math.round(angle / step) * step;
}
function countAngleByCords(x0, y0, x, y, currentAngle) {
    if (y > y0 && x >= x0) { // II quarter
        return 180 - currentAngle;
    }
    else if (y > y0 && x < x0) { // III quarter
        return 180 + currentAngle;
    }
    else if (y < y0 && x < x0) { // IV quarter
        return 360 - currentAngle;
    }
    else { // I quarter
        return currentAngle;
    }
}

let NgxMaterialTimepickerButtonComponent = class NgxMaterialTimepickerButtonComponent {
};
NgxMaterialTimepickerButtonComponent.ɵfac = function NgxMaterialTimepickerButtonComponent_Factory(t) { return new (t || NgxMaterialTimepickerButtonComponent)(); };
NgxMaterialTimepickerButtonComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NgxMaterialTimepickerButtonComponent, selectors: [["ngx-material-timepicker-button"]], ngContentSelectors: _c8, decls: 3, vars: 0, consts: [["type", "button", 1, "timepicker-button"]], template: function NgxMaterialTimepickerButtonComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "button", 0);
        ɵngcc0.ɵɵelementStart(1, "span");
        ɵngcc0.ɵɵprojection(2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } }, styles: [".timepicker-button[_ngcontent-%COMP%]{display:inline-block;height:36px;min-width:88px;line-height:36px;border:12px;border-radius:2px;background-color:transparent;text-align:center;transition:450ms cubic-bezier(.23,1,.32,1);overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;position:relative;cursor:pointer;outline:0;color:#00bfff}@supports (color:var(--button-color)){.timepicker-button[_ngcontent-%COMP%]{color:var(--button-color)}}.timepicker-button[_ngcontent-%COMP%]:focus, .timepicker-button[_ngcontent-%COMP%]:hover{background-color:rgba(153,153,153,.2)}.timepicker-button[_ngcontent-%COMP%] > span[_ngcontent-%COMP%]{font-size:14px;text-transform:uppercase;font-weight:600;padding-left:16px;padding-right:16px;font-family:Roboto,sans-serif}@supports (font-family:var(--primary-font-family)){.timepicker-button[_ngcontent-%COMP%] > span[_ngcontent-%COMP%]{font-family:var(--primary-font-family)}}"] });

let NgxMaterialTimepickerDialComponent = class NgxMaterialTimepickerDialComponent {
    constructor(locale) {
        this.locale = locale;
        this.timeUnit = TimeUnit;
        this.meridiems = Info.meridiems({ locale: this.locale });
        this.periodChanged = new EventEmitter();
        this.timeUnitChanged = new EventEmitter();
        this.hourChanged = new EventEmitter();
        this.minuteChanged = new EventEmitter();
    }
    ngOnChanges(changes) {
        if (changes['period'] && changes['period'].currentValue
            || changes['format'] && changes['format'].currentValue) {
            const hours = TimepickerTimeUtils.getHours(this.format);
            this.hours = TimepickerTimeUtils.disableHours(hours, {
                min: this.minTime,
                max: this.maxTime,
                format: this.format,
                period: this.period
            });
        }
        if (changes['period'] && changes['period'].currentValue
            || changes['hour'] && changes['hour'].currentValue) {
            const minutes = TimepickerTimeUtils.getMinutes(this.minutesGap);
            this.minutes = TimepickerTimeUtils.disableMinutes(minutes, +this.hour, {
                min: this.minTime,
                max: this.maxTime,
                format: this.format,
                period: this.period
            });
        }
    }
    changeTimeUnit(unit) {
        this.timeUnitChanged.next(unit);
    }
    changePeriod(period) {
        this.periodChanged.next(period);
    }
    changeHour(hour) {
        this.hourChanged.next(hour);
    }
    changeMinute(minute) {
        this.minuteChanged.next(minute);
    }
    showHint() {
        this.isHintVisible = true;
    }
    hideHint() {
        this.isHintVisible = false;
    }
};
NgxMaterialTimepickerDialComponent.ɵfac = function NgxMaterialTimepickerDialComponent_Factory(t) { return new (t || NgxMaterialTimepickerDialComponent)(ɵngcc0.ɵɵdirectiveInject(TIME_LOCALE)); };
NgxMaterialTimepickerDialComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NgxMaterialTimepickerDialComponent, selectors: [["ngx-material-timepicker-dial"]], inputs: { editableHintTmpl: "editableHintTmpl", hour: "hour", minute: "minute", format: "format", period: "period", activeTimeUnit: "activeTimeUnit", minTime: "minTime", maxTime: "maxTime", isEditable: "isEditable", minutesGap: "minutesGap", hoursOnly: "hoursOnly" }, outputs: { periodChanged: "periodChanged", timeUnitChanged: "timeUnitChanged", hourChanged: "hourChanged", minuteChanged: "minuteChanged" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 9, vars: 25, consts: [[1, "timepicker-dial"], [1, "timepicker-dial__container"], [1, "timepicker-dial__time"], [3, "timeList", "time", "timeUnit", "isActive", "isEditable", "timeUnitChanged", "timeChanged", "focused", "unfocused"], [3, "timeList", "time", "timeUnit", "isActive", "isEditable", "minutesGap", "disabled", "timeUnitChanged", "timeChanged", "focused", "unfocused"], [1, "timepicker-dial__period", 3, "ngClass", "selectedPeriod", "activeTimeUnit", "maxTime", "minTime", "format", "hours", "minutes", "selectedHour", "meridiems", "periodChanged"], [3, "ngClass", 4, "ngIf"], [3, "ngClass"], [4, "ngTemplateOutlet"], ["editableHintDefault", ""], [1, "timepicker-dial__hint"]], template: function NgxMaterialTimepickerDialComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵelementStart(2, "div", 2);
        ɵngcc0.ɵɵelementStart(3, "ngx-material-timepicker-dial-control", 3);
        ɵngcc0.ɵɵlistener("timeUnitChanged", function NgxMaterialTimepickerDialComponent_Template_ngx_material_timepicker_dial_control_timeUnitChanged_3_listener($event) { return ctx.changeTimeUnit($event); })("timeChanged", function NgxMaterialTimepickerDialComponent_Template_ngx_material_timepicker_dial_control_timeChanged_3_listener($event) { return ctx.changeHour($event); })("focused", function NgxMaterialTimepickerDialComponent_Template_ngx_material_timepicker_dial_control_focused_3_listener() { return ctx.showHint(); })("unfocused", function NgxMaterialTimepickerDialComponent_Template_ngx_material_timepicker_dial_control_unfocused_3_listener() { return ctx.hideHint(); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "span");
        ɵngcc0.ɵɵtext(5, ":");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(6, "ngx-material-timepicker-dial-control", 4);
        ɵngcc0.ɵɵlistener("timeUnitChanged", function NgxMaterialTimepickerDialComponent_Template_ngx_material_timepicker_dial_control_timeUnitChanged_6_listener($event) { return ctx.changeTimeUnit($event); })("timeChanged", function NgxMaterialTimepickerDialComponent_Template_ngx_material_timepicker_dial_control_timeChanged_6_listener($event) { return ctx.changeMinute($event); })("focused", function NgxMaterialTimepickerDialComponent_Template_ngx_material_timepicker_dial_control_focused_6_listener() { return ctx.showHint(); })("unfocused", function NgxMaterialTimepickerDialComponent_Template_ngx_material_timepicker_dial_control_unfocused_6_listener() { return ctx.hideHint(); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(7, "ngx-material-timepicker-period", 5);
        ɵngcc0.ɵɵlistener("periodChanged", function NgxMaterialTimepickerDialComponent_Template_ngx_material_timepicker_period_periodChanged_7_listener($event) { return ctx.changePeriod($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(8, NgxMaterialTimepickerDialComponent_div_8_Template, 4, 4, "div", 6);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("timeList", ctx.hours)("time", ctx.hour)("timeUnit", ctx.timeUnit.HOUR)("isActive", ctx.activeTimeUnit === ctx.timeUnit.HOUR)("isEditable", ctx.isEditable);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("timeList", ctx.minutes)("time", ctx.minute)("timeUnit", ctx.timeUnit.MINUTE)("isActive", ctx.activeTimeUnit === ctx.timeUnit.MINUTE)("isEditable", ctx.isEditable)("minutesGap", ctx.minutesGap)("disabled", ctx.hoursOnly);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(23, _c10, ctx.format === 24))("selectedPeriod", ctx.period)("activeTimeUnit", ctx.activeTimeUnit)("maxTime", ctx.maxTime)("minTime", ctx.minTime)("format", ctx.format)("hours", ctx.hours)("minutes", ctx.minutes)("selectedHour", ctx.hour)("meridiems", ctx.meridiems);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isEditable || ctx.editableHintTmpl);
    } }, directives: function () { return [NgxMaterialTimepickerDialControlComponent, NgxMaterialTimepickerPeriodComponent, ɵngcc1.NgClass, ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet]; }, styles: [".timepicker-dial[_ngcontent-%COMP%]{text-align:right}.timepicker-dial__container[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:flex-end;-webkit-tap-highlight-color:transparent}.timepicker-dial__time[_ngcontent-%COMP%]{display:flex;align-items:baseline;line-height:normal;font-size:50px;color:rgba(255,255,255,.5);font-family:Roboto,sans-serif}@supports (font-family:var(--primary-font-family)){.timepicker-dial__time[_ngcontent-%COMP%]{font-family:var(--primary-font-family);color:var(--dial-inactive-color)}}.timepicker-dial__period[_ngcontent-%COMP%]{display:block;margin-left:10px}.timepicker-dial__hint-container--hidden[_ngcontent-%COMP%], .timepicker-dial__period--hidden[_ngcontent-%COMP%]{visibility:hidden}.timepicker-dial__hint[_ngcontent-%COMP%]{display:inline-block;font-size:10px;color:#fff}@supports (color:var(--dial-active-color)){.timepicker-dial__hint[_ngcontent-%COMP%]{color:var(--dial-active-color)}}.timepicker-dial__hint[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]{font-size:14px}@media (max-device-width:1023px) and (orientation:landscape){.timepicker-dial__container[_ngcontent-%COMP%]{flex-direction:column}.timepicker-dial__period[_ngcontent-%COMP%]{margin-left:0}}"], changeDetection: 0 });
NgxMaterialTimepickerDialComponent.ctorParameters = () => [
    { type: String, decorators: [{ type: Inject, args: [TIME_LOCALE,] }] }
];
__decorate([
    Input()
], NgxMaterialTimepickerDialComponent.prototype, "editableHintTmpl", void 0);
__decorate([
    Input()
], NgxMaterialTimepickerDialComponent.prototype, "hour", void 0);
__decorate([
    Input()
], NgxMaterialTimepickerDialComponent.prototype, "minute", void 0);
__decorate([
    Input()
], NgxMaterialTimepickerDialComponent.prototype, "format", void 0);
__decorate([
    Input()
], NgxMaterialTimepickerDialComponent.prototype, "period", void 0);
__decorate([
    Input()
], NgxMaterialTimepickerDialComponent.prototype, "activeTimeUnit", void 0);
__decorate([
    Input()
], NgxMaterialTimepickerDialComponent.prototype, "minTime", void 0);
__decorate([
    Input()
], NgxMaterialTimepickerDialComponent.prototype, "maxTime", void 0);
__decorate([
    Input()
], NgxMaterialTimepickerDialComponent.prototype, "isEditable", void 0);
__decorate([
    Input()
], NgxMaterialTimepickerDialComponent.prototype, "minutesGap", void 0);
__decorate([
    Input()
], NgxMaterialTimepickerDialComponent.prototype, "hoursOnly", void 0);
__decorate([
    Output()
], NgxMaterialTimepickerDialComponent.prototype, "periodChanged", void 0);
__decorate([
    Output()
], NgxMaterialTimepickerDialComponent.prototype, "timeUnitChanged", void 0);
__decorate([
    Output()
], NgxMaterialTimepickerDialComponent.prototype, "hourChanged", void 0);
__decorate([
    Output()
], NgxMaterialTimepickerDialComponent.prototype, "minuteChanged", void 0);
NgxMaterialTimepickerDialComponent = __decorate([ __param(0, Inject(TIME_LOCALE))
], NgxMaterialTimepickerDialComponent);

let TimeParserPipe = class TimeParserPipe {
    constructor(locale) {
        this.locale = locale;
        this.numberingSystem = DateTime.local().setLocale(this.locale).resolvedLocaleOpts().numberingSystem;
    }
    transform(time, timeUnit = TimeUnit.HOUR) {
        if (time == null || time === '') {
            return '';
        }
        if (!isNaN(+time)) {
            return time;
        }
        if (timeUnit === TimeUnit.MINUTE) {
            return this.parseTime(time, 'm', 'minute');
        }
        return this.parseTime(time, 'H', 'hour');
    }
    parseTime(time, format, timeMeasure) {
        const parsedTime = DateTime.fromFormat(String(time), format, { numberingSystem: this.numberingSystem })[timeMeasure];
        if (!isNaN(parsedTime)) {
            return parsedTime;
        }
        throw new Error(`Cannot parse time - ${time}`);
    }
};
TimeParserPipe.ɵfac = function TimeParserPipe_Factory(t) { return new (t || TimeParserPipe)(ɵngcc0.ɵɵdirectiveInject(TIME_LOCALE)); };
TimeParserPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "timeParser", type: TimeParserPipe, pure: true });
TimeParserPipe.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: TimeParserPipe, factory: function (t) { return TimeParserPipe.ɵfac(t); } });
TimeParserPipe.ctorParameters = () => [
    { type: String, decorators: [{ type: Inject, args: [TIME_LOCALE,] }] }
];
TimeParserPipe = __decorate([ __param(0, Inject(TIME_LOCALE))
], TimeParserPipe);

let NgxMaterialTimepickerDialControlComponent = class NgxMaterialTimepickerDialControlComponent {
    constructor(timeParserPipe) {
        this.timeParserPipe = timeParserPipe;
        this.timeUnitChanged = new EventEmitter();
        this.timeChanged = new EventEmitter();
        this.focused = new EventEmitter();
        this.unfocused = new EventEmitter();
    }
    get selectedTime() {
        if (!!this.time) {
            return this.timeList.find(t => t.time === +this.time);
        }
    }
    saveTimeAndChangeTimeUnit(event, unit) {
        event.preventDefault();
        this.previousTime = this.time;
        this.timeUnitChanged.next(unit);
        this.focused.next();
    }
    updateTime() {
        const time = this.selectedTime;
        if (time) {
            this.timeChanged.next(time);
            this.previousTime = time.time;
        }
    }
    changeTimeByKeyboard(e) {
        const char = String.fromCharCode(e.keyCode);
        if (isTimeDisabledToChange(this.time, char, this.timeList)) {
            e.preventDefault();
        }
    }
    onKeydown(e) {
        if (!isDigit(e)) {
            e.preventDefault();
        }
        else {
            this.changeTimeByArrow(e.keyCode);
        }
    }
    onModelChange(value) {
        this.time = this.timeParserPipe.transform(value, this.timeUnit).toString();
    }
    changeTimeByArrow(keyCode) {
        const ARROW_UP = 38;
        const ARROW_DOWN = 40;
        let time;
        if (keyCode === ARROW_UP) {
            time = String(+this.time + (this.minutesGap || 1));
        }
        else if (keyCode === ARROW_DOWN) {
            time = String(+this.time - (this.minutesGap || 1));
        }
        if (!isTimeUnavailable(time, this.timeList)) {
            this.time = time;
            this.updateTime();
        }
    }
};
NgxMaterialTimepickerDialControlComponent.ɵfac = function NgxMaterialTimepickerDialControlComponent_Factory(t) { return new (t || NgxMaterialTimepickerDialControlComponent)(ɵngcc0.ɵɵdirectiveInject(TimeParserPipe)); };
NgxMaterialTimepickerDialControlComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NgxMaterialTimepickerDialControlComponent, selectors: [["ngx-material-timepicker-dial-control"]], inputs: { time: "time", timeList: "timeList", timeUnit: "timeUnit", isActive: "isActive", isEditable: "isEditable", minutesGap: "minutesGap", disabled: "disabled" }, outputs: { timeUnitChanged: "timeUnitChanged", timeChanged: "timeChanged", focused: "focused", unfocused: "unfocused" }, features: [ɵngcc0.ɵɵProvidersFeature([TimeParserPipe])], decls: 3, vars: 2, consts: [["class", "timepicker-dial__control timepicker-dial__item", "readonly", "", 3, "ngClass", "ngModel", "disabled", "timepickerAutofocus", "ngModelChange", "input", "focus", 4, "ngIf", "ngIfElse"], ["editableTemplate", ""], ["readonly", "", 1, "timepicker-dial__control", "timepicker-dial__item", 3, "ngClass", "ngModel", "disabled", "timepickerAutofocus", "ngModelChange", "input", "focus"], [1, "timepicker-dial__control", "timepicker-dial__item", "timepicker-dial__control_editable", 3, "ngClass", "ngModel", "disabled", "timepickerAutofocus", "ngModelChange", "input", "focus", "keydown", "keypress"]], template: function NgxMaterialTimepickerDialControlComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NgxMaterialTimepickerDialControlComponent_input_0_Template, 2, 9, "input", 0);
        ɵngcc0.ɵɵtemplate(1, NgxMaterialTimepickerDialControlComponent_ng_template_1_Template, 3, 13, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        const _r1 = ɵngcc0.ɵɵreference(2);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.isEditable)("ngIfElse", _r1);
    } }, directives: function () { return [ɵngcc1.NgIf, ɵngcc2.DefaultValueAccessor, ɵngcc1.NgClass, ɵngcc2.NgControlStatus, ɵngcc2.NgModel, AutofocusDirective]; }, pipes: function () { return [TimeLocalizerPipe, TimeParserPipe]; }, styles: [".timepicker-dial__item[_ngcontent-%COMP%]{cursor:pointer;color:rgba(255,255,255,.5);font-family:Roboto,sans-serif}@supports (font-family:var(--primary-font-family)){.timepicker-dial__item[_ngcontent-%COMP%]{font-family:var(--primary-font-family);color:var(--dial-inactive-color)}}.timepicker-dial__item_active[_ngcontent-%COMP%]{color:#fff}@supports (color:var(--dial-active-color)){.timepicker-dial__item_active[_ngcontent-%COMP%]{color:var(--dial-active-color)}}.timepicker-dial__control[_ngcontent-%COMP%]{border:none;background-color:transparent;font-size:50px;width:60px;padding:0;border-radius:3px;text-align:right}.timepicker-dial__control_editable[_ngcontent-%COMP%]:focus{color:#00bfff;background-color:#fff;outline:#00bfff}@supports (color:var(--dial-editable-active-color)){.timepicker-dial__control_editable[_ngcontent-%COMP%]:focus{color:var(--dial-editable-active-color)}}@supports (background-color:var(--dial-editable-background-color)){.timepicker-dial__control_editable[_ngcontent-%COMP%]:focus{background-color:var(--dial-editable-background-color)}}@supports (outline:var(--dial-editable-active-color)){.timepicker-dial__control_editable[_ngcontent-%COMP%]:focus{outline:var(--dial-editable-active-color)}}.timepicker-dial__control[_ngcontent-%COMP%]:disabled{cursor:default}"] });
NgxMaterialTimepickerDialControlComponent.ctorParameters = () => [
    { type: TimeParserPipe }
];
__decorate([
    Input()
], NgxMaterialTimepickerDialControlComponent.prototype, "timeList", void 0);
__decorate([
    Input()
], NgxMaterialTimepickerDialControlComponent.prototype, "timeUnit", void 0);
__decorate([
    Input()
], NgxMaterialTimepickerDialControlComponent.prototype, "time", void 0);
__decorate([
    Input()
], NgxMaterialTimepickerDialControlComponent.prototype, "isActive", void 0);
__decorate([
    Input()
], NgxMaterialTimepickerDialControlComponent.prototype, "isEditable", void 0);
__decorate([
    Input()
], NgxMaterialTimepickerDialControlComponent.prototype, "minutesGap", void 0);
__decorate([
    Input()
], NgxMaterialTimepickerDialControlComponent.prototype, "disabled", void 0);
__decorate([
    Output()
], NgxMaterialTimepickerDialControlComponent.prototype, "timeUnitChanged", void 0);
__decorate([
    Output()
], NgxMaterialTimepickerDialControlComponent.prototype, "timeChanged", void 0);
__decorate([
    Output()
], NgxMaterialTimepickerDialControlComponent.prototype, "focused", void 0);
__decorate([
    Output()
], NgxMaterialTimepickerDialControlComponent.prototype, "unfocused", void 0);
function isTimeDisabledToChange(currentTime, nextTime, timeList) {
    const isNumber = /\d/.test(nextTime);
    if (isNumber) {
        const time = currentTime + nextTime;
        return isTimeUnavailable(time, timeList);
    }
}
function isTimeUnavailable(time, timeList) {
    const selectedTime = timeList.find(value => value.time === +time);
    return !selectedTime || (selectedTime && selectedTime.disabled);
}

let NgxMaterialTimepickerPeriodComponent = class NgxMaterialTimepickerPeriodComponent {
    constructor() {
        this.timePeriod = TimePeriod;
        this.isPeriodAvailable = true;
        this.periodChanged = new EventEmitter();
    }
    changePeriod(period) {
        this.isPeriodAvailable = this.isSwitchPeriodAvailable(period);
        if (this.isPeriodAvailable) {
            this.periodChanged.next(period);
        }
    }
    animationDone() {
        this.isPeriodAvailable = true;
    }
    isSwitchPeriodAvailable(period) {
        const time = this.getDisabledTimeByPeriod(period);
        return !time.every(t => t.disabled);
    }
    getDisabledTimeByPeriod(period) {
        switch (this.activeTimeUnit) {
            case TimeUnit.HOUR:
                return TimepickerTimeUtils.disableHours(this.hours, {
                    min: this.minTime,
                    max: this.maxTime,
                    format: this.format,
                    period
                });
            case TimeUnit.MINUTE:
                return TimepickerTimeUtils.disableMinutes(this.minutes, +this.selectedHour, {
                    min: this.minTime,
                    max: this.maxTime,
                    format: this.format,
                    period
                });
            default:
                throw new Error('no such TimeUnit');
        }
    }
};
NgxMaterialTimepickerPeriodComponent.ɵfac = function NgxMaterialTimepickerPeriodComponent_Factory(t) { return new (t || NgxMaterialTimepickerPeriodComponent)(); };
NgxMaterialTimepickerPeriodComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NgxMaterialTimepickerPeriodComponent, selectors: [["ngx-material-timepicker-period"]], inputs: { selectedPeriod: "selectedPeriod", format: "format", activeTimeUnit: "activeTimeUnit", hours: "hours", minutes: "minutes", minTime: "minTime", maxTime: "maxTime", selectedHour: "selectedHour", meridiems: "meridiems" }, outputs: { periodChanged: "periodChanged" }, decls: 6, vars: 9, consts: [[1, "timepicker-period"], ["type", "button", 1, "timepicker-dial__item", "timepicker-period__btn", 3, "ngClass", "click"], ["class", "timepicker-period__warning", 4, "ngIf"], [1, "timepicker-period__warning"]], template: function NgxMaterialTimepickerPeriodComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "button", 1);
        ɵngcc0.ɵɵlistener("click", function NgxMaterialTimepickerPeriodComponent_Template_button_click_1_listener() { return ctx.changePeriod(ctx.timePeriod.AM); });
        ɵngcc0.ɵɵtext(2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "button", 1);
        ɵngcc0.ɵɵlistener("click", function NgxMaterialTimepickerPeriodComponent_Template_button_click_3_listener() { return ctx.changePeriod(ctx.timePeriod.PM); });
        ɵngcc0.ɵɵtext(4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(5, NgxMaterialTimepickerPeriodComponent_div_5_Template, 3, 1, "div", 2);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(5, _c11, ctx.selectedPeriod === ctx.timePeriod.AM));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.meridiems[0]);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(7, _c11, ctx.selectedPeriod === ctx.timePeriod.PM));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.meridiems[1]);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.isPeriodAvailable);
    } }, directives: [ɵngcc1.NgClass, ɵngcc1.NgIf], styles: [".timepicker-dial__item[_ngcontent-%COMP%]{cursor:pointer;color:rgba(255,255,255,.5);font-family:Roboto,sans-serif}@supports (font-family:var(--primary-font-family)){.timepicker-dial__item[_ngcontent-%COMP%]{font-family:var(--primary-font-family);color:var(--dial-inactive-color)}}.timepicker-dial__item_active[_ngcontent-%COMP%]{color:#fff}@supports (color:var(--dial-active-color)){.timepicker-dial__item_active[_ngcontent-%COMP%]{color:var(--dial-active-color)}}.timepicker-period[_ngcontent-%COMP%]{display:flex;flex-direction:column;position:relative}.timepicker-period__btn[_ngcontent-%COMP%]{padding:1px 3px;border:0;background-color:transparent;font-size:18px;font-weight:500;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;outline:0;border-radius:3px;transition:background-color .5s;font-family:Roboto,sans-serif}.timepicker-period__btn[_ngcontent-%COMP%]:focus{background-color:rgba(0,0,0,.07)}.timepicker-period__warning[_ngcontent-%COMP%]{padding:5px 10px;border-radius:3px;background-color:rgba(0,0,0,.55);color:#fff;position:absolute;width:200px;left:-20px;top:40px}.timepicker-period__warning[_ngcontent-%COMP%] > p[_ngcontent-%COMP%]{margin:0;font-size:12px;font-family:Roboto,sans-serif}@supports (font-family:var(--primary-font-family)){.timepicker-period__btn[_ngcontent-%COMP%], .timepicker-period__warning[_ngcontent-%COMP%] > p[_ngcontent-%COMP%]{font-family:var(--primary-font-family)}}"], data: { animation: [
            trigger('scaleInOut', [
                transition(':enter', [
                    style({ transform: 'scale(0)' }),
                    animate('.2s', style({ transform: 'scale(1)' })),
                    sequence([
                        animate('3s', style({ opacity: 1 })),
                        animate('.3s', style({ opacity: 0 }))
                    ])
                ])
            ])
        ] } });
__decorate([
    Input()
], NgxMaterialTimepickerPeriodComponent.prototype, "selectedPeriod", void 0);
__decorate([
    Input()
], NgxMaterialTimepickerPeriodComponent.prototype, "format", void 0);
__decorate([
    Input()
], NgxMaterialTimepickerPeriodComponent.prototype, "activeTimeUnit", void 0);
__decorate([
    Input()
], NgxMaterialTimepickerPeriodComponent.prototype, "hours", void 0);
__decorate([
    Input()
], NgxMaterialTimepickerPeriodComponent.prototype, "minutes", void 0);
__decorate([
    Input()
], NgxMaterialTimepickerPeriodComponent.prototype, "minTime", void 0);
__decorate([
    Input()
], NgxMaterialTimepickerPeriodComponent.prototype, "maxTime", void 0);
__decorate([
    Input()
], NgxMaterialTimepickerPeriodComponent.prototype, "selectedHour", void 0);
__decorate([
    Input()
], NgxMaterialTimepickerPeriodComponent.prototype, "meridiems", void 0);
__decorate([
    Output()
], NgxMaterialTimepickerPeriodComponent.prototype, "periodChanged", void 0);

let TimeFormatterPipe = class TimeFormatterPipe {
    transform(time, timeUnit) {
        if (time == null || time === '') {
            return time;
        }
        switch (timeUnit) {
            case TimeUnit.HOUR:
                return DateTime.fromObject({ hour: +time }).toFormat('HH');
            case TimeUnit.MINUTE:
                return DateTime.fromObject({ minute: +time }).toFormat('mm');
            default:
                throw new Error('no such time unit');
        }
    }
};
TimeFormatterPipe.ɵfac = function TimeFormatterPipe_Factory(t) { return new (t || TimeFormatterPipe)(); };
TimeFormatterPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "timeFormatter", type: TimeFormatterPipe, pure: true });

let OverlayDirective = class OverlayDirective {
    constructor(eventService) {
        this.eventService = eventService;
    }
    onClick(e) {
        if (!this.preventClick) {
            this.eventService.dispatchEvent(e);
        }
        e.preventDefault();
    }
};
OverlayDirective.ɵfac = function OverlayDirective_Factory(t) { return new (t || OverlayDirective)(ɵngcc0.ɵɵdirectiveInject(NgxMaterialTimepickerEventService)); };
OverlayDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: OverlayDirective, selectors: [["", "overlay", ""]], hostBindings: function OverlayDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function OverlayDirective_click_HostBindingHandler($event) { return ctx.onClick($event); });
    } }, inputs: { preventClick: ["overlay", "preventClick"] } });
OverlayDirective.ctorParameters = () => [
    { type: NgxMaterialTimepickerEventService }
];
__decorate([
    Input('overlay')
], OverlayDirective.prototype, "preventClick", void 0);
__decorate([
    HostListener('click', ['$event'])
], OverlayDirective.prototype, "onClick", null);

let MinutesFormatterPipe = class MinutesFormatterPipe {
    transform(minute, gap = 5) {
        if (!minute) {
            return minute;
        }
        return minute % gap === 0 ? minute : '';
    }
};
MinutesFormatterPipe.ɵfac = function MinutesFormatterPipe_Factory(t) { return new (t || MinutesFormatterPipe)(); };
MinutesFormatterPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "minutesFormatter", type: MinutesFormatterPipe, pure: true });

let AutofocusDirective = class AutofocusDirective {
    constructor(element, document) {
        this.element = element;
        this.document = document;
        this.activeElement = this.document.activeElement;
    }
    ngOnChanges() {
        if (this.isFocusActive) {
            // To avoid ExpressionChangedAfterItHasBeenCheckedError;
            setTimeout(() => this.element.nativeElement.focus({ preventScroll: true }));
        }
    }
    ngOnDestroy() {
        // To avoid ExpressionChangedAfterItHasBeenCheckedError;
        setTimeout(() => this.activeElement.focus({ preventScroll: true }));
    }
};
AutofocusDirective.ɵfac = function AutofocusDirective_Factory(t) { return new (t || AutofocusDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DOCUMENT, 8)); };
AutofocusDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AutofocusDirective, selectors: [["", "timepickerAutofocus", ""]], inputs: { isFocusActive: ["timepickerAutofocus", "isFocusActive"] }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
AutofocusDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] }
];
__decorate([
    Input('timepickerAutofocus')
], AutofocusDirective.prototype, "isFocusActive", void 0);
AutofocusDirective = __decorate([ __param(1, Optional()), __param(1, Inject(DOCUMENT))
], AutofocusDirective);

var NgxTimepickerFieldComponent_1;
let NgxTimepickerFieldComponent = NgxTimepickerFieldComponent_1 = class NgxTimepickerFieldComponent {
    constructor(timepickerService, locale) {
        this.timepickerService = timepickerService;
        this.locale = locale;
        this.minHour = 1;
        this.maxHour = 12;
        this.timeUnit = TimeUnit;
        this.buttonAlign = 'right';
        this.timeChanged = new EventEmitter();
        this._format = 12;
        this.unsubscribe$ = new Subject();
        this.isFirstTimeChange = true;
        this.onChange = () => {
        };
    }
    set format(value) {
        this._format = value === 24 ? 24 : 12;
        this.minHour = this._format === 12 ? 1 : 0;
        this.maxHour = this._format === 12 ? 12 : 23;
        this.hoursList = TimepickerTimeUtils.getHours(this._format);
        const isDynamicallyChanged = value && (this.previousFormat && this.previousFormat !== this._format);
        if (isDynamicallyChanged) {
            this.updateTime(this.timepickerTime);
        }
        this.previousFormat = this._format;
    }
    get format() {
        return this._format;
    }
    set min(value) {
        if (typeof value === 'string') {
            this._min = TimeAdapter.parseTime(value, { locale: this.locale, format: this.format });
            return;
        }
        this._min = value;
    }
    get min() {
        return this._min;
    }
    set max(value) {
        if (typeof value === 'string') {
            this._max = TimeAdapter.parseTime(value, { locale: this.locale, format: this.format });
            return;
        }
        this._max = value;
    }
    get max() {
        return this._max;
    }
    set defaultTime(val) {
        this._defaultTime = val;
        this.isDefaultTime = !!val;
    }
    get defaultTime() {
        return this._defaultTime;
    }
    ngOnInit() {
        this.initTime(this.defaultTime);
        this.hoursList = TimepickerTimeUtils.getHours(this._format);
        this.minutesList = TimepickerTimeUtils.getMinutes();
        this.isTimeRangeSet = !!(this.min || this.max);
        this.hour$ = this.timepickerService.selectedHour.pipe(tap((clockTime) => this.selectedHour = clockTime.time), map(this.changeDefaultTimeValue.bind(this)), tap(() => this.isTimeRangeSet && this.updateAvailableMinutes()));
        this.minute$ = this.timepickerService.selectedMinute.pipe(map(this.changeDefaultTimeValue.bind(this)), tap(() => this.isFirstTimeChange = false));
        if (this.format === 12) {
            this.timepickerService.selectedPeriod.pipe(distinctUntilChanged(), tap((period) => this.period = period), tap(period => this.isChangePeriodDisabled = this.isPeriodDisabled(period)), takeUntil(this.unsubscribe$)).subscribe(() => this.isTimeRangeSet && this.updateAvailableTime());
        }
    }
    writeValue(val) {
        if (val) {
            this.initTime(val);
        }
        else {
            this.resetTime();
        }
    }
    registerOnTouched(fn) {
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    changeHour(hour) {
        this.timepickerService.hour = this.hoursList.find(h => h.time === hour);
        this.changeTime();
    }
    changeMinute(minute) {
        this.timepickerService.minute = this.minutesList.find(m => m.time === minute);
        this.changeTime();
    }
    changePeriod(period) {
        this.timepickerService.period = period;
        this.changeTime();
    }
    onTimeSet(time) {
        this.updateTime(time);
        this.emitLocalTimeChange(time);
    }
    ngOnDestroy() {
        this.unsubscribe$.next();
        this.unsubscribe$.complete();
    }
    changeTime() {
        const time = this.timepickerService.getFullTime(this.format);
        this.timepickerTime = time;
        this.emitLocalTimeChange(time);
    }
    resetTime() {
        this.timepickerService.hour = { angle: 0, time: null };
        this.timepickerService.minute = { angle: 0, time: null };
    }
    emitLocalTimeChange(time) {
        const localTime = TimeAdapter.toLocaleTimeString(time, { format: this.format, locale: this.locale });
        this.onChange(localTime);
        this.timeChanged.emit(localTime);
    }
    changeDefaultTimeValue(clockFaceTime) {
        if (!this.isDefaultTime && this.isFirstTimeChange) {
            return Object.assign({}, clockFaceTime, { time: null });
        }
        return clockFaceTime;
    }
    updateAvailableHours() {
        this.hoursList = TimepickerTimeUtils.disableHours(this.hoursList, {
            min: this.min,
            max: this.max,
            format: this.format,
            period: this.period
        });
    }
    updateAvailableMinutes() {
        this.minutesList = TimepickerTimeUtils.disableMinutes(this.minutesList, this.selectedHour, {
            min: this.min,
            max: this.max,
            format: this.format,
            period: this.period
        });
    }
    updateAvailableTime() {
        this.updateAvailableHours();
        if (this.selectedHour) {
            this.updateAvailableMinutes();
        }
    }
    updateTime(time) {
        if (time) {
            const formattedTime = TimeAdapter.formatTime(time, { locale: this.locale, format: this.format });
            this.timepickerService.setDefaultTimeIfAvailable(formattedTime, this.min, this.max, this.format);
            this.timepickerTime = formattedTime;
        }
    }
    initTime(time) {
        const isDefaultTimeAvailable = TimeAdapter
            .isTimeAvailable(time, this.min, this.max, 'minutes', null, this.format);
        if (!isDefaultTimeAvailable) {
            if (this.min) {
                this.updateTime(TimeAdapter.fromDateTimeToString(this.min, this.format));
                return;
            }
            if (this.max) {
                this.updateTime(TimeAdapter.fromDateTimeToString(this.max, this.format));
                return;
            }
        }
        this.updateTime(time);
    }
    isPeriodDisabled(period) {
        return TimepickerTimeUtils.disableHours(TimepickerTimeUtils.getHours(12), {
            min: this.min,
            max: this.max,
            format: 12,
            period: period === TimePeriod.AM ? TimePeriod.PM : TimePeriod.AM
        }).every(time => time.disabled);
    }
};
NgxTimepickerFieldComponent.ɵfac = function NgxTimepickerFieldComponent_Factory(t) { return new (t || NgxTimepickerFieldComponent)(ɵngcc0.ɵɵdirectiveInject(NgxMaterialTimepickerService), ɵngcc0.ɵɵdirectiveInject(TIME_LOCALE)); };
NgxTimepickerFieldComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NgxTimepickerFieldComponent, selectors: [["ngx-timepicker-field"]], inputs: { buttonAlign: "buttonAlign", format: "format", min: "min", max: "max", defaultTime: "defaultTime", disabled: "disabled", toggleIcon: "toggleIcon", clockTheme: "clockTheme", controlOnly: "controlOnly", cancelBtnTmpl: "cancelBtnTmpl", confirmBtnTmpl: "confirmBtnTmpl" }, outputs: { timeChanged: "timeChanged" }, features: [ɵngcc0.ɵɵProvidersFeature([
            NgxMaterialTimepickerService,
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: NgxTimepickerFieldComponent_1,
                multi: true
            }
        ])], decls: 13, vars: 32, consts: [[1, "ngx-timepicker", 3, "ngClass"], [1, "ngx-timepicker__control--first", 3, "placeholder", "time", "min", "max", "timeUnit", "disabled", "timeList", "preventTyping", "timeChanged"], [1, "ngx-timepicker__time-colon", "ngx-timepicker__control--second"], [1, "ngx-timepicker__control--third", 3, "placeholder", "time", "min", "max", "timeUnit", "disabled", "timeList", "preventTyping", "timeChanged"], ["class", "ngx-timepicker__control--forth", 3, "selectedPeriod", "disabled", "periodSelected", 4, "ngIf"], ["class", "ngx-timepicker__toggle", 3, "ngClass", "for", "disabled", 4, "ngIf"], [3, "min", "max", "theme", "defaultTime", "format", "cancelBtnTmpl", "confirmBtnTmpl", "timeSet"], ["timepicker", ""], ["defaultIcon", ""], [1, "ngx-timepicker__control--forth", 3, "selectedPeriod", "disabled", "periodSelected"], [1, "ngx-timepicker__toggle", 3, "ngClass", "for", "disabled"], ["ngxMaterialTimepickerToggleIcon", ""], [4, "ngTemplateOutlet"], ["xmlns", "http://www.w3.org/2000/svg", "viewBox", "0 0 24 24", "width", "24px", "height", "24px"], ["d", "M 12 2 C 6.4889971 2 2 6.4889971 2 12 C 2 17.511003                   6.4889971 22 12 22 C 17.511003 22 22 17.511003 22 12 C 22 6.4889971 17.511003 2 12 2 z M 12 4 C 16.430123 4 20 7.5698774 20 12 C 20 16.430123 16.430123 20 12 20 C 7.5698774 20 4 16.430123 4 12 C 4 7.5698774 7.5698774 4 12 4 z M 11 6 L 11 12.414062 L 15.292969 16.707031 L 16.707031 15.292969 L 13 11.585938 L 13 6 L 11 6 z"]], template: function NgxTimepickerFieldComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "ngx-timepicker-time-control", 1);
        ɵngcc0.ɵɵlistener("timeChanged", function NgxTimepickerFieldComponent_Template_ngx_timepicker_time_control_timeChanged_1_listener($event) { return ctx.changeHour($event); });
        ɵngcc0.ɵɵpipe(2, "async");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "span", 2);
        ɵngcc0.ɵɵtext(4, ":");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(5, "ngx-timepicker-time-control", 3);
        ɵngcc0.ɵɵlistener("timeChanged", function NgxTimepickerFieldComponent_Template_ngx_timepicker_time_control_timeChanged_5_listener($event) { return ctx.changeMinute($event); });
        ɵngcc0.ɵɵpipe(6, "async");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(7, NgxTimepickerFieldComponent_ngx_timepicker_period_selector_7_Template, 1, 2, "ngx-timepicker-period-selector", 4);
        ɵngcc0.ɵɵtemplate(8, NgxTimepickerFieldComponent_ngx_material_timepicker_toggle_8_Template, 3, 6, "ngx-material-timepicker-toggle", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(9, "ngx-material-timepicker", 6, 7);
        ɵngcc0.ɵɵlistener("timeSet", function NgxTimepickerFieldComponent_Template_ngx_material_timepicker_timeSet_9_listener($event) { return ctx.onTimeSet($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(11, NgxTimepickerFieldComponent_ng_template_11_Template, 2, 0, "ng-template", null, 8, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        var tmp_2_0 = null;
        var tmp_10_0 = null;
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(30, _c13, ctx.disabled));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("placeholder", "HH")("time", (tmp_2_0 = ɵngcc0.ɵɵpipeBind1(2, 26, ctx.hour$)) == null ? null : tmp_2_0.time)("min", ctx.minHour)("max", ctx.maxHour)("timeUnit", ctx.timeUnit.HOUR)("disabled", ctx.disabled)("timeList", ctx.hoursList)("preventTyping", ctx.isTimeRangeSet);
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵproperty("placeholder", "MM")("time", (tmp_10_0 = ɵngcc0.ɵɵpipeBind1(6, 28, ctx.minute$)) == null ? null : tmp_10_0.time)("min", 0)("max", 59)("timeUnit", ctx.timeUnit.MINUTE)("disabled", ctx.disabled)("timeList", ctx.minutesList)("preventTyping", ctx.isTimeRangeSet);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.format !== 24);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.controlOnly);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("min", ctx.min)("max", ctx.max)("theme", ctx.clockTheme)("defaultTime", ctx.timepickerTime)("format", ctx.format)("cancelBtnTmpl", ctx.cancelBtnTmpl)("confirmBtnTmpl", ctx.confirmBtnTmpl);
    } }, directives: function () { return [ɵngcc1.NgClass, NgxTimepickerTimeControlComponent, ɵngcc1.NgIf, NgxMaterialTimepickerComponent, NgxTimepickerPeriodSelectorComponent, NgxMaterialTimepickerToggleComponent, NgxMaterialTimepickerToggleIconDirective, ɵngcc1.NgTemplateOutlet]; }, pipes: function () { return [ɵngcc1.AsyncPipe]; }, styles: [".ngx-timepicker[_ngcontent-%COMP%]{display:flex;align-items:center;height:100%;border-bottom:1px solid rgba(0,0,0,.12)}.ngx-timepicker--disabled[_ngcontent-%COMP%]{background:rgba(0,0,0,.07);pointer-events:none}.ngx-timepicker__time-colon[_ngcontent-%COMP%]{margin-left:10px}.ngx-timepicker__control--first[_ngcontent-%COMP%]{order:1}.ngx-timepicker__control--second[_ngcontent-%COMP%]{order:2}.ngx-timepicker__control--third[_ngcontent-%COMP%]{order:3}.ngx-timepicker__control--forth[_ngcontent-%COMP%], .ngx-timepicker__toggle[_ngcontent-%COMP%]{order:4}.ngx-timepicker__toggle--left[_ngcontent-%COMP%]{order:0}"], changeDetection: 0 });
NgxTimepickerFieldComponent.ctorParameters = () => [
    { type: NgxMaterialTimepickerService },
    { type: String, decorators: [{ type: Inject, args: [TIME_LOCALE,] }] }
];
__decorate([
    Input()
], NgxTimepickerFieldComponent.prototype, "disabled", void 0);
__decorate([
    Input()
], NgxTimepickerFieldComponent.prototype, "toggleIcon", void 0);
__decorate([
    Input()
], NgxTimepickerFieldComponent.prototype, "buttonAlign", void 0);
__decorate([
    Input()
], NgxTimepickerFieldComponent.prototype, "clockTheme", void 0);
__decorate([
    Input()
], NgxTimepickerFieldComponent.prototype, "controlOnly", void 0);
__decorate([
    Input()
], NgxTimepickerFieldComponent.prototype, "cancelBtnTmpl", void 0);
__decorate([
    Input()
], NgxTimepickerFieldComponent.prototype, "confirmBtnTmpl", void 0);
__decorate([
    Input()
], NgxTimepickerFieldComponent.prototype, "format", null);
__decorate([
    Input()
], NgxTimepickerFieldComponent.prototype, "min", null);
__decorate([
    Input()
], NgxTimepickerFieldComponent.prototype, "max", null);
__decorate([
    Input()
], NgxTimepickerFieldComponent.prototype, "defaultTime", null);
__decorate([
    Output()
], NgxTimepickerFieldComponent.prototype, "timeChanged", void 0);
NgxTimepickerFieldComponent = NgxTimepickerFieldComponent_1 = __decorate([ __param(1, Inject(TIME_LOCALE))
], NgxTimepickerFieldComponent);

let NgxTimepickerTimeControlComponent = class NgxTimepickerTimeControlComponent {
    constructor(timeParser) {
        this.timeParser = timeParser;
        this.timeChanged = new EventEmitter();
    }
    ngOnChanges(changes) {
        if (changes.timeList && this.time != null) {
            if (this.isSelectedTimeDisabled(this.time)) {
                this.setAvailableTime();
            }
        }
    }
    changeTime(event) {
        event.stopPropagation();
        const char = String.fromCharCode(event.keyCode);
        const time = concatTime(String(this.time), char);
        this.changeTimeIfValid(time);
    }
    onKeydown(event) {
        event.stopPropagation();
        if (!isDigit(event)) {
            event.preventDefault();
        }
        switch (event.key) {
            case 'ArrowUp':
                this.increase();
                break;
            case 'ArrowDown':
                this.decrease();
                break;
        }
        if (this.preventTyping && event.key !== 'Tab') {
            event.preventDefault();
        }
    }
    increase() {
        if (!this.disabled) {
            let nextTime = +this.time + 1;
            if (nextTime > this.max) {
                nextTime = this.min;
            }
            if (this.isSelectedTimeDisabled(nextTime)) {
                nextTime = this.getAvailableTime(nextTime, this.getNextAvailableTime.bind(this));
            }
            if (nextTime !== this.time) {
                this.timeChanged.emit(nextTime);
            }
        }
    }
    decrease() {
        if (!this.disabled) {
            let previousTime = +this.time - 1;
            if (previousTime < this.min) {
                previousTime = this.max;
            }
            if (this.isSelectedTimeDisabled(previousTime)) {
                previousTime = this.getAvailableTime(previousTime, this.getPrevAvailableTime.bind(this));
            }
            if (previousTime !== this.time) {
                this.timeChanged.emit(previousTime);
            }
        }
    }
    onFocus() {
        this.isFocused = true;
        this.previousTime = this.time;
    }
    onBlur() {
        this.isFocused = false;
        if (this.previousTime !== this.time) {
            this.changeTimeIfValid(+this.time);
        }
    }
    onModelChange(value) {
        this.time = +this.timeParser.transform(value, this.timeUnit);
    }
    changeTimeIfValid(value) {
        if (!isNaN(value)) {
            this.time = value;
            if (this.time > this.max) {
                const timeString = String(value);
                this.time = +timeString[timeString.length - 1];
            }
            if (this.time < this.min) {
                this.time = this.min;
            }
            this.timeChanged.emit(this.time);
        }
    }
    isSelectedTimeDisabled(time) {
        return this.timeList.find((faceTime) => faceTime.time === time).disabled;
    }
    getNextAvailableTime(index) {
        const timeCollection = this.timeList;
        const maxValue = timeCollection.length;
        for (let i = index + 1; i < maxValue; i++) {
            const time = timeCollection[i];
            if (!time.disabled) {
                return time.time;
            }
        }
    }
    getPrevAvailableTime(index) {
        for (let i = index; i >= 0; i--) {
            const time = this.timeList[i];
            if (!time.disabled) {
                return time.time;
            }
        }
    }
    getAvailableTime(currentTime, fn) {
        const currentTimeIndex = this.timeList.findIndex(time => time.time === currentTime);
        const availableTime = fn(currentTimeIndex);
        return availableTime != null ? availableTime : this.time;
    }
    setAvailableTime() {
        this.time = this.timeList.find(t => !t.disabled).time;
        this.timeChanged.emit(this.time);
    }
};
NgxTimepickerTimeControlComponent.ɵfac = function NgxTimepickerTimeControlComponent_Factory(t) { return new (t || NgxTimepickerTimeControlComponent)(ɵngcc0.ɵɵdirectiveInject(TimeParserPipe)); };
NgxTimepickerTimeControlComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NgxTimepickerTimeControlComponent, selectors: [["ngx-timepicker-time-control"]], inputs: { time: "time", min: "min", max: "max", placeholder: "placeholder", timeUnit: "timeUnit", disabled: "disabled", timeList: "timeList", preventTyping: "preventTyping" }, outputs: { timeChanged: "timeChanged" }, features: [ɵngcc0.ɵɵProvidersFeature([TimeParserPipe]), ɵngcc0.ɵɵNgOnChangesFeature], decls: 9, vars: 13, consts: [[1, "ngx-timepicker-control", 3, "ngClass"], ["maxlength", "2", 1, "ngx-timepicker-control__input", 3, "ngModel", "placeholder", "disabled", "ngModelChange", "keydown", "keypress", "focus", "blur"], [1, "ngx-timepicker-control__arrows"], ["role", "button", 1, "ngx-timepicker-control__arrow", 3, "click"]], template: function NgxTimepickerTimeControlComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "input", 1);
        ɵngcc0.ɵɵlistener("ngModelChange", function NgxTimepickerTimeControlComponent_Template_input_ngModelChange_1_listener($event) { return ctx.onModelChange($event); })("keydown", function NgxTimepickerTimeControlComponent_Template_input_keydown_1_listener($event) { return ctx.onKeydown($event); })("keypress", function NgxTimepickerTimeControlComponent_Template_input_keypress_1_listener($event) { return ctx.changeTime($event); })("focus", function NgxTimepickerTimeControlComponent_Template_input_focus_1_listener() { return ctx.onFocus(); })("blur", function NgxTimepickerTimeControlComponent_Template_input_blur_1_listener() { return ctx.onBlur(); });
        ɵngcc0.ɵɵpipe(2, "timeLocalizer");
        ɵngcc0.ɵɵpipe(3, "timeParser");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "div", 2);
        ɵngcc0.ɵɵelementStart(5, "span", 3);
        ɵngcc0.ɵɵlistener("click", function NgxTimepickerTimeControlComponent_Template_span_click_5_listener() { return ctx.increase(); });
        ɵngcc0.ɵɵtext(6, " \u25B2 ");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(7, "span", 3);
        ɵngcc0.ɵɵlistener("click", function NgxTimepickerTimeControlComponent_Template_span_click_7_listener() { return ctx.decrease(); });
        ɵngcc0.ɵɵtext(8, " \u25BC ");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(11, _c14, ctx.isFocused));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngModel", ɵngcc0.ɵɵpipeBind3(2, 4, ɵngcc0.ɵɵpipeBind2(3, 8, ctx.time, ctx.timeUnit), ctx.timeUnit, true))("placeholder", ctx.placeholder)("disabled", ctx.disabled);
    } }, directives: function () { return [ɵngcc1.NgClass, ɵngcc2.DefaultValueAccessor, ɵngcc2.MaxLengthValidator, ɵngcc2.NgControlStatus, ɵngcc2.NgModel]; }, pipes: function () { return [TimeLocalizerPipe, TimeParserPipe]; }, styles: [".ngx-timepicker-control[_ngcontent-%COMP%]{position:relative;display:flex;width:60px;height:30px;padding:0 5px;box-sizing:border-box}.ngx-timepicker-control--active[_ngcontent-%COMP%]:after{content:'';position:absolute;bottom:-2px;left:0;width:100%;height:1px;background-color:#00bfff}.ngx-timepicker-control__input[_ngcontent-%COMP%]{width:100%;height:100%;padding:0 5px 0 0;border:0;font-size:1rem;color:inherit;outline:0;text-align:center}.ngx-timepicker-control__input[_ngcontent-%COMP%]:disabled{background-color:transparent}.ngx-timepicker-control__arrows[_ngcontent-%COMP%]{position:absolute;right:2px;top:0;display:flex;flex-direction:column}.ngx-timepicker-control__arrow[_ngcontent-%COMP%]{font-size:11px;color:rgba(0,0,0,.4);cursor:pointer;transition:color .2s;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.ngx-timepicker-control__arrow[_ngcontent-%COMP%]:hover{color:rgba(0,0,0,.9)}"], changeDetection: 0 });
NgxTimepickerTimeControlComponent.ctorParameters = () => [
    { type: TimeParserPipe }
];
__decorate([
    Input()
], NgxTimepickerTimeControlComponent.prototype, "time", void 0);
__decorate([
    Input()
], NgxTimepickerTimeControlComponent.prototype, "min", void 0);
__decorate([
    Input()
], NgxTimepickerTimeControlComponent.prototype, "max", void 0);
__decorate([
    Input()
], NgxTimepickerTimeControlComponent.prototype, "placeholder", void 0);
__decorate([
    Input()
], NgxTimepickerTimeControlComponent.prototype, "timeUnit", void 0);
__decorate([
    Input()
], NgxTimepickerTimeControlComponent.prototype, "disabled", void 0);
__decorate([
    Input()
], NgxTimepickerTimeControlComponent.prototype, "timeList", void 0);
__decorate([
    Input()
], NgxTimepickerTimeControlComponent.prototype, "preventTyping", void 0);
__decorate([
    Output()
], NgxTimepickerTimeControlComponent.prototype, "timeChanged", void 0);
function concatTime(currentTime, nextTime) {
    const isNumber = /\d/.test(nextTime);
    if (isNumber) {
        const time = currentTime + nextTime;
        return +time;
    }
}

let NgxTimepickerPeriodSelectorComponent = class NgxTimepickerPeriodSelectorComponent {
    constructor(locale) {
        this.locale = locale;
        this.periodSelected = new EventEmitter();
        this.period = TimePeriod;
        this.meridiems = Info.meridiems({ locale: this.locale });
    }
    set selectedPeriod(period) {
        if (period) {
            const periods = [TimePeriod.AM, TimePeriod.PM];
            this.localizedPeriod = this.meridiems[periods.indexOf(period)];
        }
    }
    open() {
        if (!this.disabled) {
            this.isOpened = true;
        }
    }
    select(period) {
        this.periodSelected.next(period);
        this.isOpened = false;
    }
    backdropClick() {
        this.isOpened = false;
    }
};
NgxTimepickerPeriodSelectorComponent.ɵfac = function NgxTimepickerPeriodSelectorComponent_Factory(t) { return new (t || NgxTimepickerPeriodSelectorComponent)(ɵngcc0.ɵɵdirectiveInject(TIME_LOCALE)); };
NgxTimepickerPeriodSelectorComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NgxTimepickerPeriodSelectorComponent, selectors: [["ngx-timepicker-period-selector"]], inputs: { selectedPeriod: "selectedPeriod", isOpened: "isOpened", disabled: "disabled" }, outputs: { periodSelected: "periodSelected" }, decls: 9, vars: 6, consts: [[1, "period"], [1, "period-control"], ["type", "button", 1, "period-control__button", "period__btn--default", 3, "ngClass", "click"], [1, "period-control__arrow"], ["class", "period-selector", 3, "timepickerAutofocus", 4, "ngIf"], ["class", "overlay", 3, "click", 4, "ngIf"], [1, "period-selector", 3, "timepickerAutofocus"], ["type", "button", 1, "period-selector__button", "period__btn--default", 3, "ngClass", "click"], [1, "overlay", 3, "click"]], template: function NgxTimepickerPeriodSelectorComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵelementStart(2, "button", 2);
        ɵngcc0.ɵɵlistener("click", function NgxTimepickerPeriodSelectorComponent_Template_button_click_2_listener() { return ctx.open(); });
        ɵngcc0.ɵɵelementStart(3, "span");
        ɵngcc0.ɵɵtext(4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(5, "span", 3);
        ɵngcc0.ɵɵtext(6, "\u25BC");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(7, NgxTimepickerPeriodSelectorComponent_ul_7_Template, 7, 10, "ul", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(8, NgxTimepickerPeriodSelectorComponent_div_8_Template, 1, 0, "div", 5);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(4, _c16, ctx.disabled));
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate(ctx.localizedPeriod);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isOpened);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isOpened);
    } }, directives: [ɵngcc1.NgClass, ɵngcc1.NgIf, AutofocusDirective], styles: [".period[_ngcontent-%COMP%]{position:relative}.period__btn--default[_ngcontent-%COMP%]{padding:0;border:none;background-color:transparent;cursor:pointer;text-align:left;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;outline:0}.period-control[_ngcontent-%COMP%]{position:relative}.period-control__button[_ngcontent-%COMP%]{position:relative;width:60px;font-size:1rem;color:inherit;text-align:center}.period-control__button[_ngcontent-%COMP%]:not(.period-control__button--disabled):focus:after{content:'';position:absolute;bottom:-8px;left:0;width:100%;height:1px;background-color:#00bfff}.period-control__arrow[_ngcontent-%COMP%]{margin-left:10px;font-size:12px;color:rgba(0,0,0,.4)}.period-selector[_ngcontent-%COMP%]{position:absolute;top:calc(50% - 50px);right:calc(-50% + -50px);max-width:135px;width:150px;padding:6px 0;margin:0;list-style:none;background-color:#f5f5f5;box-shadow:0 1px 3px 0 rgba(0,0,0,.2),0 1px 1px 0 rgba(0,0,0,.14),0 2px 1px -1px rgba(0,0,0,.12);z-index:201}.period-selector__button[_ngcontent-%COMP%]{width:100%;height:48px;padding:0 16px;line-height:48px}.period-selector__button--active[_ngcontent-%COMP%]{color:#00bfff}.period-selector__button[_ngcontent-%COMP%]:focus{background-color:#eee}.overlay[_ngcontent-%COMP%]{position:fixed;width:100%;height:100%;top:0;left:0;background-color:transparent;z-index:200}"], data: { animation: [
            trigger('scaleInOut', [
                transition(':enter', [
                    style({ transform: 'scale(0)', opacity: 0 }),
                    animate(200, style({ transform: 'scale(1)', opacity: 1 }))
                ]),
                transition(':leave', [
                    animate(200, style({ transform: 'scale(0)', opacity: 0 }))
                ])
            ])
        ] }, changeDetection: 0 });
NgxTimepickerPeriodSelectorComponent.ctorParameters = () => [
    { type: String, decorators: [{ type: Inject, args: [TIME_LOCALE,] }] }
];
__decorate([
    Input()
], NgxTimepickerPeriodSelectorComponent.prototype, "isOpened", void 0);
__decorate([
    Input()
], NgxTimepickerPeriodSelectorComponent.prototype, "disabled", void 0);
__decorate([
    Input()
], NgxTimepickerPeriodSelectorComponent.prototype, "selectedPeriod", null);
__decorate([
    Output()
], NgxTimepickerPeriodSelectorComponent.prototype, "periodSelected", void 0);
NgxTimepickerPeriodSelectorComponent = __decorate([ __param(0, Inject(TIME_LOCALE))
], NgxTimepickerPeriodSelectorComponent);

let TimeLocalizerPipe = class TimeLocalizerPipe {
    constructor(locale) {
        this.locale = locale;
    }
    transform(time, timeUnit, isKeyboardEnabled = false) {
        if (time == null || time === '') {
            return '';
        }
        switch (timeUnit) {
            case TimeUnit.HOUR: {
                const format = (time === 0 || isKeyboardEnabled) ? 'HH' : 'H';
                return this.formatTime('hour', time, format);
            }
            case TimeUnit.MINUTE:
                return this.formatTime('minute', time, 'mm');
            default:
                throw new Error(`There is no Time Unit with type ${timeUnit}`);
        }
    }
    formatTime(timeMeasure, time, format) {
        try {
            return DateTime.fromObject({ [timeMeasure]: +time }).setLocale(this.locale).toFormat(format);
        }
        catch (_a) {
            throw new Error(`Cannot format provided time - ${time} to locale - ${this.locale}`);
        }
    }
};
TimeLocalizerPipe.ɵfac = function TimeLocalizerPipe_Factory(t) { return new (t || TimeLocalizerPipe)(ɵngcc0.ɵɵdirectiveInject(TIME_LOCALE)); };
TimeLocalizerPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "timeLocalizer", type: TimeLocalizerPipe, pure: true });
TimeLocalizerPipe.ctorParameters = () => [
    { type: String, decorators: [{ type: Inject, args: [TIME_LOCALE,] }] }
];
TimeLocalizerPipe = __decorate([ __param(0, Inject(TIME_LOCALE))
], TimeLocalizerPipe);

let ActiveHourPipe = class ActiveHourPipe {
    transform(hour, currentHour, isClockFaceDisabled) {
        if (hour == null || isClockFaceDisabled) {
            return false;
        }
        return hour === currentHour;
    }
};
ActiveHourPipe.ɵfac = function ActiveHourPipe_Factory(t) { return new (t || ActiveHourPipe)(); };
ActiveHourPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "activeHour", type: ActiveHourPipe, pure: true });

let ActiveMinutePipe = class ActiveMinutePipe {
    transform(minute, currentMinute, gap, isClockFaceDisabled) {
        if (minute == null || isClockFaceDisabled) {
            return false;
        }
        const defaultGap = 5;
        return ((currentMinute === minute) && (minute % (gap || defaultGap) === 0));
    }
};
ActiveMinutePipe.ɵfac = function ActiveMinutePipe_Factory(t) { return new (t || ActiveMinutePipe)(); };
ActiveMinutePipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "activeMinute", type: ActiveMinutePipe, pure: true });

let NgxMaterialTimepickerContentComponent = class NgxMaterialTimepickerContentComponent {
};
NgxMaterialTimepickerContentComponent.ɵfac = function NgxMaterialTimepickerContentComponent_Factory(t) { return new (t || NgxMaterialTimepickerContentComponent)(); };
NgxMaterialTimepickerContentComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NgxMaterialTimepickerContentComponent, selectors: [["ngx-material-timepicker-content"]], inputs: { appendToInput: "appendToInput", inputElement: "inputElement" }, ngContentSelectors: _c8, decls: 5, vars: 2, consts: [[3, "ngxAppendToInput", 4, "ngIf", "ngIfElse"], ["timepickerModal", ""], ["timepickerOutlet", ""], [3, "ngxAppendToInput"], [4, "ngTemplateOutlet"]], template: function NgxMaterialTimepickerContentComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, NgxMaterialTimepickerContentComponent_div_0_Template, 2, 2, "div", 0);
        ɵngcc0.ɵɵtemplate(1, NgxMaterialTimepickerContentComponent_ng_template_1_Template, 1, 1, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(3, NgxMaterialTimepickerContentComponent_ng_template_3_Template, 1, 0, "ng-template", null, 2, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        const _r1 = ɵngcc0.ɵɵreference(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.appendToInput)("ngIfElse", _r1);
    } }, directives: function () { return [ɵngcc1.NgIf, AppendToInputDirective, ɵngcc1.NgTemplateOutlet]; }, encapsulation: 2 });
__decorate([
    Input()
], NgxMaterialTimepickerContentComponent.prototype, "appendToInput", void 0);
__decorate([
    Input()
], NgxMaterialTimepickerContentComponent.prototype, "inputElement", void 0);

let AppendToInputDirective = class AppendToInputDirective {
    constructor(elementRef, renderer) {
        this.renderer = renderer;
        this.element = elementRef.nativeElement;
    }
    get inputCords() {
        return this.inputElement.getBoundingClientRect();
    }
    get direction() {
        const height = this.element.offsetHeight;
        const { bottom, top } = this._inputCords;
        const isElementFit = (window && window.innerHeight) - bottom < height;
        const isTop = isElementFit && top > height;
        const isCenter = isElementFit && top < height;
        if (isTop) {
            return 'top';
        }
        else if (isCenter) {
            return 'center';
        }
        return 'bottom';
    }
    ngAfterViewInit() {
        this._inputCords = this.inputCords;
        this._direction = this.direction;
        this.append();
    }
    changePosition() {
        const { bottom, top } = this.inputCords;
        const y = this.defineElementYByDirection(top, bottom);
        this.setStyle('top', `${y}px`);
    }
    append() {
        const { left, bottom, top } = this._inputCords;
        const y = this.defineElementYByDirection(top, bottom);
        this.setStyle('position', 'fixed');
        this.setStyle('left', `${left}px`);
        this.setStyle('top', `${y}px`);
    }
    setStyle(style, value) {
        this.renderer.setStyle(this.element, style, value);
    }
    defineElementYByDirection(inputTop, inputBottom) {
        if (this._direction === 'top') {
            return inputTop - this.element.offsetHeight;
        }
        else if (this._direction === 'center') {
            return inputTop - (this.element.offsetHeight / 2);
        }
        return inputBottom;
    }
};
AppendToInputDirective.ɵfac = function AppendToInputDirective_Factory(t) { return new (t || AppendToInputDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
AppendToInputDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AppendToInputDirective, selectors: [["", "ngxAppendToInput", ""]], hostBindings: function AppendToInputDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("scroll", function AppendToInputDirective_scroll_HostBindingHandler() { return ctx.changePosition(); }, false, ɵngcc0.ɵɵresolveWindow);
    } }, inputs: { inputElement: ["ngxAppendToInput", "inputElement"] } });
AppendToInputDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
__decorate([
    Input('ngxAppendToInput')
], AppendToInputDirective.prototype, "inputElement", void 0);
__decorate([
    HostListener('window:scroll')
], AppendToInputDirective.prototype, "changePosition", null);

var NgxMaterialTimepickerModule_1;
let NgxMaterialTimepickerModule = NgxMaterialTimepickerModule_1 = class NgxMaterialTimepickerModule {
    static setLocale(locale) {
        return {
            ngModule: NgxMaterialTimepickerModule_1,
            providers: [
                { provide: TIME_LOCALE, useValue: locale }
            ]
        };
    }
};
NgxMaterialTimepickerModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NgxMaterialTimepickerModule });
NgxMaterialTimepickerModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NgxMaterialTimepickerModule_Factory(t) { return new (t || NgxMaterialTimepickerModule)(); }, imports: [[
            CommonModule,
            FormsModule
        ]] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxMaterialTimepickerEventService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return []; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DomService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ɵngcc0.ComponentFactoryResolver }, { type: ɵngcc0.ApplicationRef }, { type: ɵngcc0.Injector }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [DOCUMENT]
            }] }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxMaterialTimepickerService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return []; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxMaterialTimepickerContainerComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-material-timepicker-container',
                template: "<div class=\"timepicker-backdrop-overlay\" [overlay]=\"preventOverlayClick\"\n     [ngClass]=\"{'timepicker-backdrop-overlay--transparent': appendToInput}\"></div>\n<div class=\"timepicker-overlay\">\n    <ngx-material-timepicker-content [appendToInput]=\"appendToInput\"\n                                     [inputElement]=\"inputElement\"\n                                     [ngxMaterialTimepickerTheme]=\"theme\">\n        <div class=\"timepicker\"\n             [@timepicker]=\"animationState\"\n             (@timepicker.done)=\"animationDone($event)\"\n             [ngClass]=\"timepickerClass\">\n            <header class=\"timepicker__header\">\n                <ngx-material-timepicker-dial [format]=\"format\" [hour]=\"(selectedHour | async)?.time\"\n                                              [minute]=\"(selectedMinute | async)?.time\"\n                                              [period]=\"selectedPeriod | async\"\n                                              [activeTimeUnit]=\"activeTimeUnit\"\n                                              [minTime]=\"minTime\"\n                                              [maxTime]=\"maxTime\"\n                                              [isEditable]=\"enableKeyboardInput\"\n                                              [editableHintTmpl]=\"editableHintTmpl\"\n                                              [minutesGap]=\"minutesGap\"\n                                              [hoursOnly]=\"hoursOnly\"\n                                              (periodChanged)=\"changePeriod($event)\"\n                                              (timeUnitChanged)=\"changeTimeUnit($event)\"\n                                              (hourChanged)=\"onHourChange($event)\"\n                                              (minuteChanged)=\"onMinuteChange($event)\"\n                ></ngx-material-timepicker-dial>\n            </header>\n            <div class=\"timepicker__main-content\">\n                <div class=\"timepicker__body\" [ngSwitch]=\"activeTimeUnit\">\n                    <div *ngSwitchCase=\"timeUnit.HOUR\">\n                        <ngx-material-timepicker-24-hours-face *ngIf=\"format === 24;else ampmHours\"\n                                                               (hourChange)=\"onHourChange($event)\"\n                                                               [selectedHour]=\"selectedHour | async\"\n                                                               [minTime]=\"minTime\"\n                                                               [maxTime]=\"maxTime\"\n                                                               [format]=\"format\"\n                                                               (hourSelected)=\"onHourSelected($event)\"></ngx-material-timepicker-24-hours-face>\n                        <ng-template #ampmHours>\n                            <ngx-material-timepicker-12-hours-face\n                                (hourChange)=\"onHourChange($event)\"\n                                [selectedHour]=\"selectedHour | async\"\n                                [period]=\"selectedPeriod | async\"\n                                [minTime]=\"minTime\"\n                                [maxTime]=\"maxTime\"\n                                (hourSelected)=\"onHourSelected($event)\"></ngx-material-timepicker-12-hours-face>\n                        </ng-template>\n                    </div>\n                    <ngx-material-timepicker-minutes-face *ngSwitchCase=\"timeUnit.MINUTE\"\n                                                          [selectedMinute]=\"selectedMinute | async\"\n                                                          [selectedHour]=\"(selectedHour | async)?.time\"\n                                                          [minTime]=\"minTime\"\n                                                          [maxTime]=\"maxTime\"\n                                                          [format]=\"format\"\n                                                          [period]=\"selectedPeriod | async\"\n                                                          [minutesGap]=\"minutesGap\"\n                                                          (minuteChange)=\"onMinuteChange($event)\"></ngx-material-timepicker-minutes-face>\n                </div>\n                <div class=\"timepicker__actions\">\n                    <div (click)=\"close()\">\n                        <!--suppress HtmlUnknownAttribute -->\n                        <ng-container\n                            *ngTemplateOutlet=\"cancelBtnTmpl ? cancelBtnTmpl : cancelBtnDefault\"></ng-container>\n                    </div>\n                    <div (click)=\"setTime()\">\n                        <!--suppress HtmlUnknownAttribute -->\n                        <ng-container\n                            *ngTemplateOutlet=\"confirmBtnTmpl ? confirmBtnTmpl : confirmBtnDefault\"></ng-container>\n                    </div>\n                </div>\n            </div>\n        </div>\n    </ngx-material-timepicker-content>\n</div>\n<ng-template #cancelBtnDefault>\n    <ngx-material-timepicker-button>Cancel</ngx-material-timepicker-button>\n</ng-template>\n<ng-template #confirmBtnDefault>\n    <ngx-material-timepicker-button>Ok</ngx-material-timepicker-button>\n</ng-template>\n",
                animations: [
                    trigger('timepicker', [
                        transition(`* => ${AnimationState.ENTER}`, [
                            style({ transform: 'translateY(-30%)' }),
                            animate('0.2s ease-out', style({ transform: 'translateY(0)' }))
                        ]),
                        transition(`${AnimationState.ENTER} => ${AnimationState.LEAVE}`, [
                            style({ transform: 'translateY(0)', opacity: 1 }),
                            animate('0.2s ease-out', style({ transform: 'translateY(-30%)', opacity: 0 }))
                        ])
                    ])
                ],
                providers: [NgxMaterialTimepickerService],
                styles: [":host{--body-background-color:#fff;--primary-font-family:'Roboto',sans-serif;--button-color:deepskyblue;--dial-active-color:#fff;--dial-inactive-color:rgba(255, 255, 255, .5);--dial-background-color:deepskyblue;--dial-editable-active-color:deepskyblue;--dial-editable-background-color:#fff;--clock-face-time-active-color:#fff;--clock-face-time-inactive-color:#6c6c6c;--clock-face-inner-time-inactive-color:#929292;--clock-face-time-disabled-color:#c5c5c5;--clock-face-background-color:#f0f0f0;--clock-hand-color:deepskyblue}.timepicker-backdrop-overlay{position:fixed;top:0;bottom:0;right:0;left:0;background-color:rgba(0,0,0,.3);z-index:999;pointer-events:auto}.timepicker-backdrop-overlay--transparent{background-color:transparent}.timepicker-overlay{position:fixed;top:0;left:0;width:100%;height:100%;display:flex;justify-content:center;align-items:center;z-index:999;pointer-events:none}.timepicker{width:300px;border-radius:2px;box-shadow:rgba(0,0,0,.25) 0 14px 45px,rgba(0,0,0,.22) 0 10px 18px;outline:0;position:static;z-index:999;pointer-events:auto}.timepicker__header{padding:15px 30px;background-color:#00bfff}@supports (background-color:var(--dial-background-color)){.timepicker__header{background-color:var(--dial-background-color)}}.timepicker__body{padding:15px 5px;display:flex;justify-content:center;align-items:center;background-color:#fff}@supports (background-color:var(--body-background-color)){.timepicker__body{background-color:var(--body-background-color)}}.timepicker__actions{display:flex;justify-content:flex-end;padding:15px;background-color:#fff}@supports (background-color:var(--body-background-color)){.timepicker__actions{background-color:var(--body-background-color)}}@media (max-device-width:1023px) and (orientation:landscape){.timepicker{display:flex;width:515px}.timepicker__header{display:flex;align-items:center}.timepicker__main-content{display:flex;flex-direction:column;width:100%}.timepicker__actions{padding:5px;margin-top:-1px}}"]
            }]
    }], function () { return [{ type: NgxMaterialTimepickerService }, { type: NgxMaterialTimepickerEventService }, { type: String, decorators: [{
                type: Inject,
                args: [TIME_LOCALE]
            }] }]; }, { defaultTime: [{
            type: Input
        }], onKeydown: [{
            type: HostListener,
            args: ['keydown', ['$event']]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxMaterialTimepickerComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-material-timepicker',
                template: ''
            }]
    }], function () { return [{ type: NgxMaterialTimepickerEventService }, { type: DomService }]; }, { isEsc: [{
            type: Input,
            args: ['ESC']
        }], hoursOnly: [{
            type: Input
        }], timeSet: [{
            type: Output
        }], opened: [{
            type: Output
        }], closed: [{
            type: Output
        }], hourSelected: [{
            type: Output
        }], timeChanged: [{
            type: Output
        }], ngxMaterialTimepickerTheme: [{
            type: Input
        }], format: [{
            type: Input
        }], minutesGap: [{
            type: Input
        }], cancelBtnTmpl: [{
            type: Input
        }], editableHintTmpl: [{
            type: Input
        }], confirmBtnTmpl: [{
            type: Input
        }], enableKeyboardInput: [{
            type: Input
        }], preventOverlayClick: [{
            type: Input
        }], disableAnimation: [{
            type: Input
        }], appendToInput: [{
            type: Input
        }], defaultTime: [{
            type: Input
        }], timepickerClass: [{
            type: Input
        }], theme: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxMaterialTimepickerToggleIconDirective, [{
        type: Directive,
        args: [{ selector: '[ngxMaterialTimepickerToggleIcon]' }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxMaterialTimepickerToggleComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-material-timepicker-toggle',
                template: "<button class=\"ngx-material-timepicker-toggle\" (click)=\"open($event)\" [disabled]=\"disabled\" type=\"button\">\n    <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" width=\"24px\" height=\"24px\" *ngIf=\"!customIcon\">\n        <path\n            d=\"M 12 2 C 6.4889971 2 2 6.4889971 2 12 C 2 17.511003                   6.4889971 22 12 22 C 17.511003 22 22 17.511003 22 12 C 22 6.4889971 17.511003 2 12 2 z M 12 4 C 16.430123 4 20 7.5698774 20 12 C 20 16.430123 16.430123 20 12 20 C 7.5698774 20 4 16.430123 4 12 C 4 7.5698774 7.5698774 4 12 4 z M 11 6 L 11 12.414062 L 15.292969 16.707031 L 16.707031 15.292969 L 13 11.585938 L 13 6 L 11 6 z\"/>\n    </svg>\n\n    <ng-content select=\"[ngxMaterialTimepickerToggleIcon]\"></ng-content>\n</button>\n",
                styles: [".ngx-material-timepicker-toggle{display:flex;justify-content:center;align-items:center;padding:4px;background-color:transparent;border-radius:50%;text-align:center;border:none;outline:0;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:background-color .3s;cursor:pointer}.ngx-material-timepicker-toggle:focus{background-color:rgba(0,0,0,.07)}"]
            }]
    }], null, { disabled: [{
            type: Input
        }], timepicker: [{
            type: Input,
            args: ['for']
        }], customIcon: [{
            type: ContentChild,
            args: [NgxMaterialTimepickerToggleIconDirective, { static: true }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TimepickerDirective, [{
        type: Directive,
        args: [{
                selector: '[ngxTimepicker]',
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: TimepickerDirective_1,
                        multi: true
                    }
                ],
                host: {
                    '[disabled]': 'disabled',
                    '(change)': 'updateValue($event.target.value)',
                    '(blur)': 'onTouched()'
                }
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: String, decorators: [{
                type: Inject,
                args: [TIME_LOCALE]
            }] }]; }, { format: [{
            type: Input
        }], value: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], timepicker: [{
            type: Input,
            args: ['ngxTimepicker']
        }], onClick: [{
            type: HostListener,
            args: ['click', ['$event']]
        }], disabled: [{
            type: Input
        }], disableClick: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxMaterialTimepickerThemeDirective, [{
        type: Directive,
        args: [{ selector: '[ngxMaterialTimepickerTheme]' }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { theme: [{
            type: Input,
            args: ['ngxMaterialTimepickerTheme']
        }] }); })();

/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxMaterialTimepicker24HoursFaceComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-material-timepicker-24-hours-face',
                template: "<ngx-material-timepicker-face [selectedTime]=\"selectedHour\" [faceTime]=\"hoursList\" [format]=\"format\"\n                              (timeChange)=\"hourChange.next($event)\"\n                              (timeSelected)=\"onTimeSelected($event)\"></ngx-material-timepicker-face>\n",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxMaterialTimepicker12HoursFaceComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-material-timepicker-12-hours-face',
                template: "<ngx-material-timepicker-face [selectedTime]=\"selectedHour\" [faceTime]=\"hoursList\"\n                              (timeChange)=\"hourChange.next($event)\" (timeSelected)=\"onTimeSelected($event)\"></ngx-material-timepicker-face>\n",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { period: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxMaterialTimepickerMinutesFaceComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-material-timepicker-minutes-face',
                template: "<ngx-material-timepicker-face [faceTime]=\"minutesList\" [selectedTime]=\"selectedMinute\"\n                              [minutesGap]=\"minutesGap\"\n                              (timeChange)=\"minuteChange.next($event)\" [unit]=\"timeUnit.MINUTE\"></ngx-material-timepicker-face>\n"
            }]
    }], function () { return []; }, { minuteChange: [{
            type: Output
        }], selectedMinute: [{
            type: Input
        }], selectedHour: [{
            type: Input
        }], period: [{
            type: Input
        }], minTime: [{
            type: Input
        }], maxTime: [{
            type: Input
        }], format: [{
            type: Input
        }], minutesGap: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxMaterialTimepickerFaceComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-material-timepicker-face',
                template: "<div class=\"clock-face\" #clockFace>\n    <div *ngIf=\"unit !== timeUnit.MINUTE;else minutesFace\" class=\"clock-face__container\">\n        <div class=\"clock-face__number clock-face__number--outer\"\n             [ngStyle]=\"{'transform': 'rotateZ('+ time.angle +'deg) translateX(-50%)'}\"\n             *ngFor=\"let time of faceTime | slice: 0 : 12; trackBy: trackByTime\">\n\t\t\t<span [ngStyle]=\"{'transform': 'rotateZ(-'+ time.angle +'deg)'}\"\n                  [ngClass]=\"{'active': time.time | activeHour: selectedTime.time : isClockFaceDisabled,\n                   'disabled': time.disabled}\">\n                {{time.time | timeLocalizer: timeUnit.HOUR}}\n            </span>\n        </div>\n        <div class=\"clock-face__inner\" *ngIf=\"faceTime.length > 12\"\n             [style.top]=\"'calc(50% - ' + innerClockFaceSize + 'px)'\">\n            <div class=\"clock-face__number clock-face__number--inner\"\n                 [ngStyle]=\"{'transform': 'rotateZ('+ time.angle +'deg) translateX(-50%)'}\"\n                 [style.height.px]=\"innerClockFaceSize\"\n                 *ngFor=\"let time of faceTime | slice: 12 : 24; trackBy: trackByTime\">\n\t\t\t<span [ngStyle]=\"{'transform': 'rotateZ(-'+ time.angle +'deg)'}\"\n                  [ngClass]=\"{'active': time.time | activeHour: selectedTime?.time : isClockFaceDisabled,\n                   'disabled': time.disabled}\">\n                {{time.time | timeLocalizer: timeUnit.HOUR}}</span>\n            </div>\n        </div>\n    </div>\n\n    <span class=\"clock-face__clock-hand\" [ngClass]=\"{'clock-face__clock-hand_minute': unit === timeUnit.MINUTE}\"\n          #clockHand [hidden]=\"isClockFaceDisabled\"></span>\n</div>\n<ng-template #minutesFace>\n    <div class=\"clock-face__container\">\n        <div class=\"clock-face__number clock-face__number--outer\"\n             [ngStyle]=\"{'transform': 'rotateZ('+ time.angle +'deg) translateX(-50%)'}\"\n             *ngFor=\"let time of faceTime; trackBy: trackByTime\">\n\t<span [ngStyle]=\"{'transform': 'rotateZ(-'+ time.angle +'deg)'}\"\n          [ngClass]=\"{'active': time.time | activeMinute: selectedTime?.time:minutesGap:isClockFaceDisabled,\n           'disabled': time.disabled}\">\n\t{{time.time | minutesFormatter: minutesGap | timeLocalizer: timeUnit.MINUTE}}</span>\n        </div>\n    </div>\n</ng-template>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".clock-face{width:290px;height:290px;border-radius:50%;position:relative;display:flex;justify-content:center;padding:20px;box-sizing:border-box;background-color:#f0f0f0}@supports (background-color:var(--clock-face-background-color)){.clock-face{background-color:var(--clock-face-background-color)}}.clock-face__inner{position:absolute}.clock-face__container{margin-left:-2px}.clock-face__number{position:absolute;transform-origin:0 100%;width:50px;text-align:center;z-index:2}.clock-face__number--outer{height:calc(290px / 2 - 20px)}.clock-face__number--outer>span{font-size:16px;color:#6c6c6c}@supports (color:var(--clock-face-time-inactive-color)){.clock-face__number--outer>span{color:var(--clock-face-time-inactive-color)}}.clock-face__number--inner>span{font-size:14px;color:#929292}@supports (color:var(--clock-face-inner-time-inactive-color)){.clock-face__number--inner>span{color:var(--clock-face-inner-time-inactive-color)}}.clock-face__number>span{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:30px;height:30px;display:flex;justify-content:center;align-items:center;margin:auto;border-radius:50%;font-weight:500;font-family:Roboto,sans-serif}@supports (font-family:var(--primary-font-family)){.clock-face__number>span{font-family:var(--primary-font-family)}}.clock-face__number>span.active{background-color:#00bfff;color:#fff}@supports (background-color:var(--clock-hand-color)){.clock-face__number>span.active{background-color:var(--clock-hand-color);color:var(--clock-face-time-active-color)}}.clock-face__number>span.disabled{color:#c5c5c5}@supports (color:var(--clock-face-time-disabled-color)){.clock-face__number>span.disabled{color:var(--clock-face-time-disabled-color)}}.clock-face__clock-hand{height:103px;width:2px;transform-origin:0 100%;position:absolute;top:calc(50% - 103px);z-index:1;background-color:#00bfff}@supports (background-color:var(--clock-hand-color)){.clock-face__clock-hand{background-color:var(--clock-hand-color)}}.clock-face__clock-hand:after{content:'';width:7px;height:7px;border-radius:50%;background-color:inherit;position:absolute;bottom:-3px;left:-3.5px}.clock-face__clock-hand_minute:before{content:'';width:7px;height:7px;background-color:#fff;border-radius:50%;position:absolute;top:-8px;left:calc(50% - 8px);box-sizing:content-box;border:4px solid #00bfff}@supports (border-color:var(--clock-hand-color)){.clock-face__clock-hand_minute:before{border-color:var(--clock-hand-color)}}@media (max-device-width:1023px) and (orientation:landscape){.clock-face{width:225px;height:225px;padding:5px}.clock-face__number--outer{height:calc(225px / 2 - 5px)}.clock-face__clock-hand_minute:before{top:0}}"]
            }]
    }], function () { return []; }, { timeChange: [{
            type: Output
        }], timeSelected: [{
            type: Output
        }], selectedTime: [{
            type: Input
        }], onMousedown: [{
            type: HostListener,
            args: ['mousedown', ['$event']]
        }], selectTime: [{
            type: HostListener,
            args: ['click', ['$event']]
        }, {
            type: HostListener,
            args: ['touchmove', ['$event.changedTouches[0]']]
        }, {
            type: HostListener,
            args: ['touchend', ['$event.changedTouches[0]']]
        }, {
            type: HostListener,
            args: ['mousemove', ['$event']]
        }], onMouseup: [{
            type: HostListener,
            args: ['mouseup', ['$event']]
        }], faceTime: [{
            type: Input
        }], unit: [{
            type: Input
        }], format: [{
            type: Input
        }], minutesGap: [{
            type: Input
        }], clockFace: [{
            type: ViewChild,
            args: ['clockFace', { static: true }]
        }], clockHand: [{
            type: ViewChild,
            args: ['clockHand', { static: true }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxMaterialTimepickerButtonComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-material-timepicker-button',
                template: "<button class=\"timepicker-button\" type=\"button\">\n  <span><ng-content></ng-content></span>\n</button>\n",
                styles: [".timepicker-button{display:inline-block;height:36px;min-width:88px;line-height:36px;border:12px;border-radius:2px;background-color:transparent;text-align:center;transition:450ms cubic-bezier(.23,1,.32,1);overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;position:relative;cursor:pointer;outline:0;color:#00bfff}@supports (color:var(--button-color)){.timepicker-button{color:var(--button-color)}}.timepicker-button:focus,.timepicker-button:hover{background-color:rgba(153,153,153,.2)}.timepicker-button>span{font-size:14px;text-transform:uppercase;font-weight:600;padding-left:16px;padding-right:16px;font-family:Roboto,sans-serif}@supports (font-family:var(--primary-font-family)){.timepicker-button>span{font-family:var(--primary-font-family)}}"]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxMaterialTimepickerDialComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-material-timepicker-dial',
                template: "<div class=\"timepicker-dial\">\n    <div class=\"timepicker-dial__container\">\n        <div class=\"timepicker-dial__time\">\n            <ngx-material-timepicker-dial-control [timeList]=\"hours\" [time]=\"hour\" [timeUnit]=\"timeUnit.HOUR\"\n                                                  [isActive]=\"activeTimeUnit === timeUnit.HOUR\"\n                                                  [isEditable]=\"isEditable\"\n                                                  (timeUnitChanged)=\"changeTimeUnit($event)\"\n                                                  (timeChanged)=\"changeHour($event)\"\n                                                  (focused)=\"showHint()\"\n                                                  (unfocused)=\"hideHint()\">\n\n            </ngx-material-timepicker-dial-control>\n            <span>:</span>\n            <ngx-material-timepicker-dial-control [timeList]=\"minutes\" [time]=\"minute\" [timeUnit]=\"timeUnit.MINUTE\"\n                                                  [isActive]=\"activeTimeUnit === timeUnit.MINUTE\"\n                                                  [isEditable]=\"isEditable\"\n                                                  [minutesGap]=\"minutesGap\"\n                                                  [disabled]=\"hoursOnly\"\n                                                  (timeUnitChanged)=\"changeTimeUnit($event)\"\n                                                  (timeChanged)=\"changeMinute($event)\"\n                                                  (focused)=\"showHint()\"\n                                                  (unfocused)=\"hideHint()\">\n\n            </ngx-material-timepicker-dial-control>\n        </div>\n        <ngx-material-timepicker-period class=\"timepicker-dial__period\"\n                                        [ngClass]=\"{'timepicker-dial__period--hidden': format === 24}\"\n                                        [selectedPeriod]=\"period\" [activeTimeUnit]=\"activeTimeUnit\"\n                                        [maxTime]=\"maxTime\" [minTime]=\"minTime\" [format]=\"format\"\n                                        [hours]=\"hours\" [minutes]=\"minutes\" [selectedHour]=\"hour\"\n                                        [meridiems]=\"meridiems\"\n                                        (periodChanged)=\"changePeriod($event)\"></ngx-material-timepicker-period>\n    </div>\n    <div *ngIf=\"isEditable || editableHintTmpl\" [ngClass]=\"{'timepicker-dial__hint-container--hidden': !isHintVisible}\">\n        <!--suppress HtmlUnknownAttribute -->\n        <ng-container *ngTemplateOutlet=\"editableHintTmpl ? editableHintTmpl : editableHintDefault\"></ng-container>\n        <ng-template #editableHintDefault>\n            <small class=\"timepicker-dial__hint\"> * use arrows (<span>&#8645;</span>) to change the time</small>\n        </ng-template>\n    </div>\n</div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".timepicker-dial{text-align:right}.timepicker-dial__container{display:flex;align-items:center;justify-content:flex-end;-webkit-tap-highlight-color:transparent}.timepicker-dial__time{display:flex;align-items:baseline;line-height:normal;font-size:50px;color:rgba(255,255,255,.5);font-family:Roboto,sans-serif}@supports (font-family:var(--primary-font-family)){.timepicker-dial__time{font-family:var(--primary-font-family);color:var(--dial-inactive-color)}}.timepicker-dial__period{display:block;margin-left:10px}.timepicker-dial__hint-container--hidden,.timepicker-dial__period--hidden{visibility:hidden}.timepicker-dial__hint{display:inline-block;font-size:10px;color:#fff}@supports (color:var(--dial-active-color)){.timepicker-dial__hint{color:var(--dial-active-color)}}.timepicker-dial__hint span{font-size:14px}@media (max-device-width:1023px) and (orientation:landscape){.timepicker-dial__container{flex-direction:column}.timepicker-dial__period{margin-left:0}}"]
            }]
    }], function () { return [{ type: String, decorators: [{
                type: Inject,
                args: [TIME_LOCALE]
            }] }]; }, { periodChanged: [{
            type: Output
        }], timeUnitChanged: [{
            type: Output
        }], hourChanged: [{
            type: Output
        }], minuteChanged: [{
            type: Output
        }], editableHintTmpl: [{
            type: Input
        }], hour: [{
            type: Input
        }], minute: [{
            type: Input
        }], format: [{
            type: Input
        }], period: [{
            type: Input
        }], activeTimeUnit: [{
            type: Input
        }], minTime: [{
            type: Input
        }], maxTime: [{
            type: Input
        }], isEditable: [{
            type: Input
        }], minutesGap: [{
            type: Input
        }], hoursOnly: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TimeParserPipe, [{
        type: Pipe,
        args: [{
                name: 'timeParser'
            }]
    }, {
        type: Injectable
    }], function () { return [{ type: String, decorators: [{
                type: Inject,
                args: [TIME_LOCALE]
            }] }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxMaterialTimepickerDialControlComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-material-timepicker-dial-control',
                template: "<!--suppress HtmlFormInputWithoutLabel, HtmlUnknownAttribute -->\n<input class=\"timepicker-dial__control timepicker-dial__item\"\n       [ngClass]=\"{'timepicker-dial__item_active': isActive}\"\n       [ngModel]=\"time | timeLocalizer: timeUnit\"\n       (ngModelChange)=\"time = $event\"\n       [disabled]=\"disabled\"\n       (input)=\"updateTime()\" (focus)=\"saveTimeAndChangeTimeUnit($event, timeUnit)\"\n       readonly [timepickerAutofocus]=\"isActive\"\n       *ngIf=\"!isEditable;else editableTemplate\">\n\n<ng-template #editableTemplate>\n    <!--suppress HtmlFormInputWithoutLabel, HtmlUnknownAttribute -->\n    <input class=\"timepicker-dial__control timepicker-dial__item timepicker-dial__control_editable\"\n           [ngClass]=\"{'timepicker-dial__item_active': isActive}\"\n           [ngModel]=\"time | timeParser: timeUnit | timeLocalizer: timeUnit : true\"\n           (ngModelChange)=\"onModelChange($event)\"\n           [disabled]=\"disabled\"\n           (input)=\"updateTime()\" (focus)=\"saveTimeAndChangeTimeUnit($event, timeUnit)\"\n           [timepickerAutofocus]=\"isActive\" (keydown)=\"onKeydown($event)\" (keypress)=\"changeTimeByKeyboard($event)\">\n</ng-template>\n",
                providers: [TimeParserPipe],
                styles: [".timepicker-dial__item{cursor:pointer;color:rgba(255,255,255,.5);font-family:Roboto,sans-serif}@supports (font-family:var(--primary-font-family)){.timepicker-dial__item{font-family:var(--primary-font-family);color:var(--dial-inactive-color)}}.timepicker-dial__item_active{color:#fff}@supports (color:var(--dial-active-color)){.timepicker-dial__item_active{color:var(--dial-active-color)}}.timepicker-dial__control{border:none;background-color:transparent;font-size:50px;width:60px;padding:0;border-radius:3px;text-align:right}.timepicker-dial__control_editable:focus{color:#00bfff;background-color:#fff;outline:#00bfff}@supports (color:var(--dial-editable-active-color)){.timepicker-dial__control_editable:focus{color:var(--dial-editable-active-color)}}@supports (background-color:var(--dial-editable-background-color)){.timepicker-dial__control_editable:focus{background-color:var(--dial-editable-background-color)}}@supports (outline:var(--dial-editable-active-color)){.timepicker-dial__control_editable:focus{outline:var(--dial-editable-active-color)}}.timepicker-dial__control:disabled{cursor:default}"]
            }]
    }], function () { return [{ type: TimeParserPipe }]; }, { timeUnitChanged: [{
            type: Output
        }], timeChanged: [{
            type: Output
        }], focused: [{
            type: Output
        }], unfocused: [{
            type: Output
        }], time: [{
            type: Input
        }], timeList: [{
            type: Input
        }], timeUnit: [{
            type: Input
        }], isActive: [{
            type: Input
        }], isEditable: [{
            type: Input
        }], minutesGap: [{
            type: Input
        }], disabled: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxMaterialTimepickerPeriodComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-material-timepicker-period',
                template: "<div class=\"timepicker-period\">\n\t\t\t<button class=\"timepicker-dial__item timepicker-period__btn\"\n                  [ngClass]=\"{'timepicker-dial__item_active': selectedPeriod === timePeriod.AM}\"\n                  (click)=\"changePeriod(timePeriod.AM)\"\n                  type=\"button\">{{meridiems[0]}}</button>\n    <button class=\"timepicker-dial__item timepicker-period__btn\"\n          [ngClass]=\"{'timepicker-dial__item_active': selectedPeriod === timePeriod.PM}\"\n          (click)=\"changePeriod(timePeriod.PM)\"\n          type=\"button\">{{meridiems[1]}}</button>\n    <div class=\"timepicker-period__warning\" [@scaleInOut] (@scaleInOut.done)=\"animationDone()\" *ngIf=\"!isPeriodAvailable\">\n        <p>Current time would be invalid in this period.</p>\n    </div>\n</div>\n",
                animations: [
                    trigger('scaleInOut', [
                        transition(':enter', [
                            style({ transform: 'scale(0)' }),
                            animate('.2s', style({ transform: 'scale(1)' })),
                            sequence([
                                animate('3s', style({ opacity: 1 })),
                                animate('.3s', style({ opacity: 0 }))
                            ])
                        ])
                    ])
                ],
                styles: [".timepicker-dial__item{cursor:pointer;color:rgba(255,255,255,.5);font-family:Roboto,sans-serif}@supports (font-family:var(--primary-font-family)){.timepicker-dial__item{font-family:var(--primary-font-family);color:var(--dial-inactive-color)}}.timepicker-dial__item_active{color:#fff}@supports (color:var(--dial-active-color)){.timepicker-dial__item_active{color:var(--dial-active-color)}}.timepicker-period{display:flex;flex-direction:column;position:relative}.timepicker-period__btn{padding:1px 3px;border:0;background-color:transparent;font-size:18px;font-weight:500;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;outline:0;border-radius:3px;transition:background-color .5s;font-family:Roboto,sans-serif}.timepicker-period__btn:focus{background-color:rgba(0,0,0,.07)}.timepicker-period__warning{padding:5px 10px;border-radius:3px;background-color:rgba(0,0,0,.55);color:#fff;position:absolute;width:200px;left:-20px;top:40px}.timepicker-period__warning>p{margin:0;font-size:12px;font-family:Roboto,sans-serif}@supports (font-family:var(--primary-font-family)){.timepicker-period__btn,.timepicker-period__warning>p{font-family:var(--primary-font-family)}}"]
            }]
    }], function () { return []; }, { periodChanged: [{
            type: Output
        }], selectedPeriod: [{
            type: Input
        }], format: [{
            type: Input
        }], activeTimeUnit: [{
            type: Input
        }], hours: [{
            type: Input
        }], minutes: [{
            type: Input
        }], minTime: [{
            type: Input
        }], maxTime: [{
            type: Input
        }], selectedHour: [{
            type: Input
        }], meridiems: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TimeFormatterPipe, [{
        type: Pipe,
        args: [{
                name: 'timeFormatter'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(OverlayDirective, [{
        type: Directive,
        args: [{
                selector: '[overlay]'
            }]
    }], function () { return [{ type: NgxMaterialTimepickerEventService }]; }, { onClick: [{
            type: HostListener,
            args: ['click', ['$event']]
        }], preventClick: [{
            type: Input,
            args: ['overlay']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MinutesFormatterPipe, [{
        type: Pipe,
        args: [{
                name: 'minutesFormatter'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AutofocusDirective, [{
        type: Directive,
        args: [{
                selector: '[timepickerAutofocus]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [DOCUMENT]
            }] }]; }, { isFocusActive: [{
            type: Input,
            args: ['timepickerAutofocus']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxTimepickerFieldComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-timepicker-field',
                template: "<div class=\"ngx-timepicker\" [ngClass]=\"{'ngx-timepicker--disabled': disabled}\">\n    <ngx-timepicker-time-control\n        class=\"ngx-timepicker__control--first\"\n        [placeholder]=\"'HH'\"\n        [time]=\"(hour$ | async)?.time\"\n        [min]=\"minHour\"\n        [max]=\"maxHour\"\n        [timeUnit]=\"timeUnit.HOUR\"\n        [disabled]=\"disabled\"\n        [timeList]=\"hoursList\"\n        [preventTyping]=\"isTimeRangeSet\"\n        (timeChanged)=\"changeHour($event)\"></ngx-timepicker-time-control>\n    <span class=\"ngx-timepicker__time-colon ngx-timepicker__control--second\">:</span>\n    <ngx-timepicker-time-control\n        class=\"ngx-timepicker__control--third\"\n        [placeholder]=\"'MM'\"\n        [time]=\"(minute$ | async)?.time\"\n        [min]=\"0\"\n        [max]=\"59\"\n        [timeUnit]=\"timeUnit.MINUTE\"\n        [disabled]=\"disabled\"\n        [timeList]=\"minutesList\"\n        [preventTyping]=\"isTimeRangeSet\"\n        (timeChanged)=\"changeMinute($event)\"></ngx-timepicker-time-control>\n    <ngx-timepicker-period-selector\n        class=\"ngx-timepicker__control--forth\"\n        [selectedPeriod]=\"period\"\n        [disabled]=\"disabled || isChangePeriodDisabled\"\n        (periodSelected)=\"changePeriod($event)\"\n        *ngIf=\"format !== 24\"></ngx-timepicker-period-selector>\n    <ngx-material-timepicker-toggle\n        class=\"ngx-timepicker__toggle\"\n        *ngIf=\"!controlOnly\"\n        [ngClass]=\"{'ngx-timepicker__toggle--left': buttonAlign === 'left'}\"\n        [for]=\"timepicker\"\n        [disabled]=\"disabled\">\n        <span ngxMaterialTimepickerToggleIcon>\n            <!--suppress HtmlUnknownAttribute -->\n            <ng-container *ngTemplateOutlet=\"toggleIcon || defaultIcon\"></ng-container>\n        </span>\n    </ngx-material-timepicker-toggle>\n</div>\n<ngx-material-timepicker\n    [min]=\"min\"\n    [max]=\"max\"\n    [theme]=\"clockTheme\"\n    [defaultTime]=\"timepickerTime\"\n    [format]=\"format\"\n    [cancelBtnTmpl]=\"cancelBtnTmpl\"\n    [confirmBtnTmpl]=\"confirmBtnTmpl\"\n    (timeSet)=\"onTimeSet($event)\" #timepicker></ngx-material-timepicker>\n\n<ng-template #defaultIcon>\n    <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" width=\"24px\" height=\"24px\">\n        <!--suppress CheckEmptyScriptTag -->\n        <path\n            d=\"M 12 2 C 6.4889971 2 2 6.4889971 2 12 C 2 17.511003                   6.4889971 22 12 22 C 17.511003 22 22 17.511003 22 12 C 22 6.4889971 17.511003 2 12 2 z M 12 4 C 16.430123 4 20 7.5698774 20 12 C 20 16.430123 16.430123 20 12 20 C 7.5698774 20 4 16.430123 4 12 C 4 7.5698774 7.5698774 4 12 4 z M 11 6 L 11 12.414062 L 15.292969 16.707031 L 16.707031 15.292969 L 13 11.585938 L 13 6 L 11 6 z\"/>\n    </svg>\n</ng-template>\n",
                providers: [
                    NgxMaterialTimepickerService,
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: NgxTimepickerFieldComponent_1,
                        multi: true
                    }
                ],
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".ngx-timepicker{display:flex;align-items:center;height:100%;border-bottom:1px solid rgba(0,0,0,.12)}.ngx-timepicker--disabled{background:rgba(0,0,0,.07);pointer-events:none}.ngx-timepicker__time-colon{margin-left:10px}.ngx-timepicker__control--first{order:1}.ngx-timepicker__control--second{order:2}.ngx-timepicker__control--third{order:3}.ngx-timepicker__control--forth,.ngx-timepicker__toggle{order:4}.ngx-timepicker__toggle--left{order:0}"]
            }]
    }], function () { return [{ type: NgxMaterialTimepickerService }, { type: String, decorators: [{
                type: Inject,
                args: [TIME_LOCALE]
            }] }]; }, { buttonAlign: [{
            type: Input
        }], timeChanged: [{
            type: Output
        }], format: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], defaultTime: [{
            type: Input
        }], disabled: [{
            type: Input
        }], toggleIcon: [{
            type: Input
        }], clockTheme: [{
            type: Input
        }], controlOnly: [{
            type: Input
        }], cancelBtnTmpl: [{
            type: Input
        }], confirmBtnTmpl: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxTimepickerTimeControlComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-timepicker-time-control',
                template: "<div class=\"ngx-timepicker-control\" [ngClass]=\"{'ngx-timepicker-control--active': isFocused}\">\n    <!--suppress HtmlFormInputWithoutLabel -->\n    <input class=\"ngx-timepicker-control__input\"\n           maxlength=\"2\"\n           [ngModel]=\"time | timeParser: timeUnit | timeLocalizer: timeUnit : true\"\n           (ngModelChange)=\"onModelChange($event)\"\n           [placeholder]=\"placeholder\"\n           [disabled]=\"disabled\"\n           (keydown)=\"onKeydown($event)\"\n           (keypress)=\"changeTime($event)\"\n           (focus)=\"onFocus()\"\n           (blur)=\"onBlur()\">\n    <div class=\"ngx-timepicker-control__arrows\">\n            <span class=\"ngx-timepicker-control__arrow\" role=\"button\" (click)=\"increase()\">\n                &#9650;\n            </span>\n        <span class=\"ngx-timepicker-control__arrow\" role=\"button\" (click)=\"decrease()\">\n                &#9660;\n            </span>\n    </div>\n</div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [TimeParserPipe],
                styles: [".ngx-timepicker-control{position:relative;display:flex;width:60px;height:30px;padding:0 5px;box-sizing:border-box}.ngx-timepicker-control--active:after{content:'';position:absolute;bottom:-2px;left:0;width:100%;height:1px;background-color:#00bfff}.ngx-timepicker-control__input{width:100%;height:100%;padding:0 5px 0 0;border:0;font-size:1rem;color:inherit;outline:0;text-align:center}.ngx-timepicker-control__input:disabled{background-color:transparent}.ngx-timepicker-control__arrows{position:absolute;right:2px;top:0;display:flex;flex-direction:column}.ngx-timepicker-control__arrow{font-size:11px;color:rgba(0,0,0,.4);cursor:pointer;transition:color .2s;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.ngx-timepicker-control__arrow:hover{color:rgba(0,0,0,.9)}"]
            }]
    }], function () { return [{ type: TimeParserPipe }]; }, { timeChanged: [{
            type: Output
        }], time: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], placeholder: [{
            type: Input
        }], timeUnit: [{
            type: Input
        }], disabled: [{
            type: Input
        }], timeList: [{
            type: Input
        }], preventTyping: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxTimepickerPeriodSelectorComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-timepicker-period-selector',
                template: "<div class=\"period\">\n    <div class=\"period-control\">\n        <button class=\"period-control__button period__btn--default\"\n                [ngClass]=\"{'period-control__button--disabled': disabled}\"\n                type=\"button\"\n                (click)=\"open()\">\n            <span>{{localizedPeriod}}</span>\n            <span class=\"period-control__arrow\">&#9660;</span>\n        </button>\n    </div>\n    <ul class=\"period-selector\" @scaleInOut *ngIf=\"isOpened\" [timepickerAutofocus]=\"true\">\n        <li>\n            <button class=\"period-selector__button period__btn--default\"\n                    type=\"button\"\n                    (click)=\"select(period.AM)\"\n                    [ngClass]=\"{'period-selector__button--active': localizedPeriod === meridiems[0]}\">{{meridiems[0]}}</button>\n        </li>\n        <li>\n            <button class=\"period-selector__button period__btn--default\"\n                    type=\"button\"\n                    (click)=\"select(period.PM)\"\n                    [ngClass]=\"{'period-selector__button--active': localizedPeriod === meridiems[1]}\">{{meridiems[1]}}</button>\n        </li>\n    </ul>\n</div>\n<div class=\"overlay\" (click)=\"backdropClick()\" *ngIf=\"isOpened\"></div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                animations: [
                    trigger('scaleInOut', [
                        transition(':enter', [
                            style({ transform: 'scale(0)', opacity: 0 }),
                            animate(200, style({ transform: 'scale(1)', opacity: 1 }))
                        ]),
                        transition(':leave', [
                            animate(200, style({ transform: 'scale(0)', opacity: 0 }))
                        ])
                    ])
                ],
                styles: [".period{position:relative}.period__btn--default{padding:0;border:none;background-color:transparent;cursor:pointer;text-align:left;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;outline:0}.period-control{position:relative}.period-control__button{position:relative;width:60px;font-size:1rem;color:inherit;text-align:center}.period-control__button:not(.period-control__button--disabled):focus:after{content:'';position:absolute;bottom:-8px;left:0;width:100%;height:1px;background-color:#00bfff}.period-control__arrow{margin-left:10px;font-size:12px;color:rgba(0,0,0,.4)}.period-selector{position:absolute;top:calc(50% - 50px);right:calc(-50% + -50px);max-width:135px;width:150px;padding:6px 0;margin:0;list-style:none;background-color:#f5f5f5;box-shadow:0 1px 3px 0 rgba(0,0,0,.2),0 1px 1px 0 rgba(0,0,0,.14),0 2px 1px -1px rgba(0,0,0,.12);z-index:201}.period-selector__button{width:100%;height:48px;padding:0 16px;line-height:48px}.period-selector__button--active{color:#00bfff}.period-selector__button:focus{background-color:#eee}.overlay{position:fixed;width:100%;height:100%;top:0;left:0;background-color:transparent;z-index:200}"]
            }]
    }], function () { return [{ type: String, decorators: [{
                type: Inject,
                args: [TIME_LOCALE]
            }] }]; }, { periodSelected: [{
            type: Output
        }], selectedPeriod: [{
            type: Input
        }], isOpened: [{
            type: Input
        }], disabled: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TimeLocalizerPipe, [{
        type: Pipe,
        args: [{
                name: 'timeLocalizer'
            }]
    }], function () { return [{ type: String, decorators: [{
                type: Inject,
                args: [TIME_LOCALE]
            }] }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ActiveHourPipe, [{
        type: Pipe,
        args: [{
                name: 'activeHour'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ActiveMinutePipe, [{
        type: Pipe,
        args: [{
                name: 'activeMinute'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxMaterialTimepickerContentComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-material-timepicker-content',
                template: "<div [ngxAppendToInput]=\"inputElement\" *ngIf=\"appendToInput;else timepickerModal\">\n    <!--suppress HtmlUnknownAttribute -->\n    <ng-container *ngTemplateOutlet=\"timepickerOutlet\"></ng-container>\n</div>\n\n<ng-template #timepickerModal>\n    <!--suppress HtmlUnknownAttribute -->\n    <ng-container *ngTemplateOutlet=\"timepickerOutlet\"></ng-container>\n</ng-template>\n\n<ng-template #timepickerOutlet>\n    <ng-content></ng-content>\n</ng-template>\n"
            }]
    }], null, { appendToInput: [{
            type: Input
        }], inputElement: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AppendToInputDirective, [{
        type: Directive,
        args: [{
                selector: '[ngxAppendToInput]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { changePosition: [{
            type: HostListener,
            args: ['window:scroll']
        }], inputElement: [{
            type: Input,
            args: ['ngxAppendToInput']
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgxMaterialTimepickerModule, { declarations: function () { return [NgxMaterialTimepickerComponent, NgxMaterialTimepicker24HoursFaceComponent, NgxMaterialTimepicker12HoursFaceComponent, NgxMaterialTimepickerMinutesFaceComponent, NgxMaterialTimepickerFaceComponent, NgxMaterialTimepickerToggleComponent, NgxMaterialTimepickerButtonComponent, NgxMaterialTimepickerDialComponent, NgxMaterialTimepickerDialControlComponent, NgxMaterialTimepickerPeriodComponent, TimeFormatterPipe, TimepickerDirective, OverlayDirective, NgxMaterialTimepickerToggleIconDirective, AutofocusDirective, MinutesFormatterPipe, NgxMaterialTimepickerThemeDirective, NgxTimepickerFieldComponent, NgxTimepickerTimeControlComponent, NgxTimepickerPeriodSelectorComponent, TimeLocalizerPipe, TimeParserPipe, ActiveHourPipe, ActiveMinutePipe, NgxMaterialTimepickerContainerComponent, NgxMaterialTimepickerContentComponent, AppendToInputDirective]; }, imports: function () { return [CommonModule,
        FormsModule]; }, exports: function () { return [NgxMaterialTimepickerComponent, NgxMaterialTimepickerToggleComponent, NgxTimepickerFieldComponent, TimepickerDirective, NgxMaterialTimepickerToggleIconDirective, NgxMaterialTimepickerThemeDirective, NgxMaterialTimepicker24HoursFaceComponent, NgxMaterialTimepicker12HoursFaceComponent, NgxMaterialTimepickerMinutesFaceComponent, NgxMaterialTimepickerFaceComponent, NgxMaterialTimepickerDialComponent, NgxMaterialTimepickerDialControlComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxMaterialTimepickerModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    FormsModule
                ],
                exports: [
                    NgxMaterialTimepickerComponent,
                    NgxMaterialTimepickerToggleComponent,
                    NgxTimepickerFieldComponent,
                    TimepickerDirective,
                    NgxMaterialTimepickerToggleIconDirective,
                    NgxMaterialTimepickerThemeDirective,
                    NgxMaterialTimepicker24HoursFaceComponent,
                    NgxMaterialTimepicker12HoursFaceComponent,
                    NgxMaterialTimepickerMinutesFaceComponent,
                    NgxMaterialTimepickerFaceComponent,
                    NgxMaterialTimepickerDialComponent,
                    NgxMaterialTimepickerDialControlComponent
                ],
                declarations: [
                    NgxMaterialTimepickerComponent,
                    NgxMaterialTimepicker24HoursFaceComponent,
                    NgxMaterialTimepicker12HoursFaceComponent,
                    NgxMaterialTimepickerMinutesFaceComponent,
                    NgxMaterialTimepickerFaceComponent,
                    NgxMaterialTimepickerToggleComponent,
                    NgxMaterialTimepickerButtonComponent,
                    NgxMaterialTimepickerDialComponent,
                    NgxMaterialTimepickerDialControlComponent,
                    NgxMaterialTimepickerPeriodComponent,
                    TimeFormatterPipe,
                    TimepickerDirective,
                    OverlayDirective,
                    NgxMaterialTimepickerToggleIconDirective,
                    AutofocusDirective,
                    MinutesFormatterPipe,
                    NgxMaterialTimepickerThemeDirective,
                    NgxTimepickerFieldComponent,
                    NgxTimepickerTimeControlComponent,
                    NgxTimepickerPeriodSelectorComponent,
                    TimeLocalizerPipe,
                    TimeParserPipe,
                    ActiveHourPipe,
                    ActiveMinutePipe,
                    NgxMaterialTimepickerContainerComponent,
                    NgxMaterialTimepickerContentComponent,
                    AppendToInputDirective
                ],
                entryComponents: [NgxMaterialTimepickerContainerComponent]
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { NgxMaterialTimepicker12HoursFaceComponent, NgxMaterialTimepicker24HoursFaceComponent, NgxMaterialTimepickerComponent, NgxMaterialTimepickerDialComponent, NgxMaterialTimepickerDialControlComponent, NgxMaterialTimepickerFaceComponent, NgxMaterialTimepickerMinutesFaceComponent, NgxMaterialTimepickerModule, NgxMaterialTimepickerThemeDirective, NgxMaterialTimepickerToggleIconDirective, NgxTimepickerFieldComponent, TimepickerDirective, NgxMaterialTimepickerEventService as ɵa, DomService as ɵb, NgxMaterialTimepickerToggleComponent as ɵc, NgxMaterialTimepickerService as ɵd, TIME_LOCALE as ɵe, NgxMaterialTimepickerHoursFace as ɵf, TimeParserPipe as ɵg, NgxMaterialTimepickerButtonComponent as ɵh, NgxMaterialTimepickerPeriodComponent as ɵi, TimeFormatterPipe as ɵj, OverlayDirective as ɵk, AutofocusDirective as ɵl, MinutesFormatterPipe as ɵm, NgxTimepickerTimeControlComponent as ɵn, NgxTimepickerPeriodSelectorComponent as ɵo, TimeLocalizerPipe as ɵp, ActiveHourPipe as ɵq, ActiveMinutePipe as ɵr, AnimationState as ɵs, NgxMaterialTimepickerContainerComponent as ɵt, NgxMaterialTimepickerContentComponent as ɵu, AppendToInputDirective as ɵv };

//# sourceMappingURL=ngx-material-timepicker.js.map